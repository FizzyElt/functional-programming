<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>208</anchor> <rss>cat-0001.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0001</addr>  <route>cat-0001.xml</route> <date><year>2023</year> <month>9</month> <day>9</day></date> <authors><author><link href="dannypsnl.xml" type="local" dannypsnl="addr">Lîm Tsú-thuàn</link></author> </authors> <title>直覺 Category</title> </frontmatter> <mainmatter><p>
說直覺是因為我們這裡未有完善定義何謂 <link href="set-0001.xml" type="local" addr="set-0001" title="本性類與良性類">class</link> 跟 <link href="set-0001.xml" type="local" addr="set-0001" title="本性類與良性類">set</link>，但是作為入門或是簡要使用的定義「夠好」。
我們說 <tex>\mathcal {C}</tex> 是一個範疇的意思是：

<ol><li>
    有 <tex>Ob( \mathcal {C} )</tex> 物件 <strong>class</strong>，表示範疇中的物件。作為方便的記號，當 <tex>a</tex> 為 <tex>\mathcal {C}</tex> 中一物件，我們記成 <tex>a  \in  Ob( \mathcal {C} )</tex></li>
  <li>
    當有 <tex>a, b  \in  Ob( \mathcal {C} )</tex>，而 <tex>f</tex> 為一 <tex>a</tex> 到 <tex>b</tex> 之態射(morphism) ，記為 <tex>f  \in   \mathcal {C} (a, b)</tex> 或是 <tex>f : a  \to  b</tex>。
    態射可以組合，也就是說當有 <tex>f : a  \to  b</tex> 且 <tex>g : b  \to  c</tex>，存在一個兩個的組合態射 <tex>f  \circ  g</tex>。
    與上面相同，<tex>\mathcal {C} (a, b)</tex> 是一個態射 <strong>class</strong></li>
  <li><tex>id_a \  id_b</tex> 對 <tex>f:a \to  b</tex> 滿足 <tex>f \circ  id_a = f</tex> 跟 <tex>id_b \circ  f = f</tex></li>
  <li><tex>(f \circ  g) \circ  h=f \circ  (g \circ  h)</tex></li></ol>

  要是對每個 <tex>a,b</tex> 之間的全部 morphism <tex>\mathcal {C} (a, b)</tex> 是一個集合，就說範疇 locally small；要是整個範疇中所有的 morphism 是一個集合，那範疇就是 small。
  深入技術細節會讓你更了解為什麼需要定義這麼多東西，但在最開始的時候，只要簡單的相信範疇給定的定義即可。
</p></mainmatter> <backmatter><contributions/> <context/> <related><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>209</anchor> <rss>set-0001.rss.xml</rss>  <addr>set-0001</addr>  <route>set-0001.xml</route> <date><year>2023</year> <month>9</month> <day>9</day></date> <authors><author><link href="dannypsnl.xml" type="local" dannypsnl="addr">Lîm Tsú-thuàn</link></author> </authors> <title>本性類與良性類</title> </frontmatter> <mainmatter><p>
  類區分為兩種：一種是可以順利進行類運算的「良性類」，我們把這種「良性類」稱為集合；另一種是要限制運算的「本性類」，對於本性類，類運算並不是都能進行的。
  更多資料可以參照數學導論
</p></mainmatter> </tree></related> <backlinks><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>210</anchor> <rss>cat-0004.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0004</addr>  <route>cat-0004.xml</route> <date><year>2023</year> <month>10</month> <day>24</day></date> <authors><author><link href="dannypsnl.xml" type="local" dannypsnl="addr">Lîm Tsú-thuàn</link></author> </authors> <title>Cartesian closed category</title> </frontmatter> <mainmatter><p>
  一個<link href="cat-0001.xml" type="local" addr="cat-0001" title="直覺 Category">範疇</link> <tex>C</tex> 被稱為 cartesian closed 表示
  <ol><li>任意有限多個 objects <tex>\{ a_i  \mid  i  \in   \mathbb {N} \}</tex> 的 product <tex>a_0  \times  ...  \times  a_n</tex> 亦是範疇的 object</li>
    <li>對所有 object <tex>a  \in  C</tex> 而言，functor <tex>a  \times  - : C  \to  C</tex> 是 <tex>(-)^a : C  \to  C</tex> 的<link href="https://en.wikipedia.org/wiki/Adjoint_functors" type="external">右伴隨</link></li></ol></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>211</anchor> <rss>alg-0005.rss.xml</rss> <taxon>Definition</taxon> <addr>alg-0005</addr>  <route>alg-0005.xml</route> <date><year>2023</year> <month>9</month> <day>13</day></date> <authors><author><link href="fizzyelt.xml" type="local" fizzyelt="addr">FizzyElt</link></author> <contributor><link href="dannypsnl.xml" type="local" dannypsnl="addr">Lîm Tsú-thuàn</link></contributor></authors> <title>Monoid</title> </frontmatter> <mainmatter><p><link href="https://en.wikipedia.org/wiki/Monoid" type="external">Monoid</link> 是有 identity element 的 <link href="alg-0003.xml" type="local" addr="alg-0003" title="Semigroup">semigroup</link>，其中 identity element <tex>e</tex> 滿足</p><tex display="block">
  e  \bullet  a = a = a  \bullet  e
</tex><p>如果把 id morphism 對應到 <tex>e</tex>，而剩餘的 morphism 對應到每個 monoid 的元素上，那麼只有一個 object 的 <link href="cat-0001.xml" type="local" addr="cat-0001" title="直覺 Category">small category</link> 正好是一個 monoid。</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>212</anchor> <rss>fp-000O.rss.xml</rss> <taxon>Example</taxon> <addr>fp-000O</addr>  <route>fp-000O.xml</route> <date><year>2023</year> <month>9</month> <day>13</day></date> <authors><author><link href="fizzyelt.xml" type="local" fizzyelt="addr">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local" dannypsnl="addr">Lîm Tsú-thuàn</link></author> </authors> <title>函數組合</title> </frontmatter> <mainmatter><p>在禁止 free variable 的 lambda calculus 中，可以將 monoid 用作模型</p><ul><li><tex>e</tex> 就是 <tex>\lambda  x. x</tex></li>
  <li>函數 <tex>f, g</tex> 的組合 <tex>f  \circ  g</tex> 是 <tex>\lambda  x. f (g  \;  x)</tex></li></ul><p>identity law 的檢查比較容易，這裡我們就來看結合律如何運作：</p><tex display="block">\begin {aligned}
  &amp;f  \circ  (g  \circ  h)
   \\ 
  &amp;=  \lambda  x. f ((g  \circ  h)  \;  x)
   \\ 
  &amp;=  \lambda  x. f (( \lambda  x. g (h  \;  x))  \;  x)
   \\ 
  &amp;=  \lambda  x. f (g (h  \;  x))
 \\ 
  &amp;(f  \circ  g)  \circ  h
   \\ 
  &amp;=  \lambda  x. (f  \circ  g)(h  \;  x)
   \\ 
  &amp;=  \lambda  x. ( \lambda  x. f (g  \;  x)) (h  \;  x)
   \\ 
  &amp;=  \lambda  x. f (g (h  \;  x))
 \end {aligned}</tex><p>確實滿足要求。</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>213</anchor> <rss>cs-0001.rss.xml</rss> <taxon>Example</taxon> <addr>cs-0001</addr>  <route>cs-0001.xml</route> <date><year>2023</year> <month>9</month> <day>13</day></date> <authors><author><link href="fizzyelt.xml" type="local" fizzyelt="addr">FizzyElt</link></author> </authors> <title>半自動機</title> </frontmatter> <mainmatter><p>對給定的半自動機可以討論其 <link href="https://planetmath.org/CharacteristicMonoid" type="external">characteristic monoid</link>。一個半自動機是個三元組 <tex>(Q,  \Sigma , T)</tex></p><ul><li><tex>Q</tex> 是一個非空的「狀態集合」</li>
  <li><tex>\Sigma</tex> 是一個「輸入字母表」的非空集合</li>
  <li><tex>T</tex> 是轉移函數</li></ul><p>假設一個 <tex>M(Q,  \Sigma , T)</tex> 集合</p><tex display="block">
  M(Q, \  \Sigma , \  T) =  \{  T_w \  | \  w \in   \Sigma ^*  \} 
</tex><p>集合 <tex>M(Q, \  \Sigma , \  T)</tex> 在<strong>函數複合</strong>下閉合；就是說，對於所有 <tex>v,w  \in   \Sigma ^*</tex> ，有 <tex>T_w  \circ  T_v = T_{vw}</tex> 。它還包含 <tex>T_ \epsilon</tex> ，而這個 <tex>T_ \epsilon</tex> 是個<strong>恆等函數(即 identity function)</strong>。 </p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>214</anchor> <rss>cat-0002.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0002</addr>  <route>cat-0002.xml</route> <date><year>2023</year> <month>9</month> <day>11</day></date> <authors><author><link href="dannypsnl.xml" type="local" dannypsnl="addr">Lîm Tsú-thuàn</link></author> </authors> <title>Functor</title> </frontmatter> <mainmatter><p>
  Let <tex>\mathcal {C}   \to   \mathcal {D}</tex> be <link href="cat-0001.xml" type="local" addr="cat-0001" title="直覺 Category">categories</link>. To specify a <em>functor</em> <tex>F</tex> from <tex>\mathcal {C}</tex> to <tex>\mathcal {D}</tex>, denoted <tex>F :  \mathcal {C}   \to   \mathcal {D}</tex>

  <ol><li>for every object <tex>c  \in  Ob( \mathcal {C} )</tex>, one specifies an object <tex>F(c)  \in  Ob( \mathcal {D} )</tex>;</li>
    <li>for every morphism <tex>f : c_1  \to  c_2</tex> in <tex>\mathcal {C}</tex>, one specifies a morphism <tex>F(f) : F(c_1)  \to  F(c_2)</tex> in <tex>\mathcal {D}</tex>.</li></ol>

  And they must satisfy two properties:

  <ol><li>
      for every object <tex>c  \in  Ob( \mathcal {C} )</tex>, we have <tex>F(id_c) = id_{F(c)}</tex>;
    </li>
    <li>
      for every three objects <tex>c_1, c_2, c_3  \in  Ob( \mathcal {C} )</tex> and two morphisms <tex>f  \in   \mathcal {C} (c_1, c_2)</tex> and <tex>g  \in   \mathcal {C} (c_2, c_3)</tex>, the equation <tex>F(f  \circ  g) = F(f)  \circ  F(g)</tex> holds in <tex>\mathcal {D}</tex>.
    </li></ol></p></mainmatter> </tree></backlinks> <references/></backmatter></tree>