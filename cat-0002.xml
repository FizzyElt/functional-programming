<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>276</anchor> <rss>cat-0002.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0002</addr>  <route>cat-0002.xml</route> <date><year>2023</year> <month>9</month> <day>11</day></date> <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>Functor</title> </frontmatter> <mainmatter><p>  Let <tex>\mathcal{C}   \to   \mathcal{D}</tex> be <link href="cat-0001.xml" type="local" title="直覺 Category">categories</link>. To specify a <em>functor</em> <tex>F</tex> from <tex>\mathcal{C}</tex> to <tex>\mathcal{D}</tex>, denoted <tex>F :  \mathcal{C}   \to   \mathcal{D}</tex>  <ol>    <li>for every object <tex>c  \in  Ob( \mathcal{C} )</tex>, one specifies an object <tex>F(c)  \in  Ob( \mathcal{D} )</tex>;</li>    <li>for every morphism <tex>f : c_1  \to  c_2</tex> in <tex>\mathcal{C}</tex>, one specifies a morphism <tex>F(f) : F(c_1)  \to  F(c_2)</tex> in <tex>\mathcal{D}</tex>.</li>  </ol>  And they must satisfy two properties:
  <ol>    <li>      for every object <tex>c  \in  Ob{ \mathcal{C} }</tex>, we have <tex>F(id_c) = id_{F(c)}</tex>;
    </li>    <li>      for every three objects <tex>c_1, c_2, c_3  \in  Ob( \mathcal{C} )</tex> and two morphisms <tex>f  \in   \mathcal{C} (c_1, c_2)</tex> and <tex>g  \in   \mathcal{C} (c_2, c_3)</tex>, the equation <tex>F(f  \circ  g) = F(f)  \circ  F(g)</tex> holds in <tex>\mathcal{D}</tex>.
    </li>  </ol></p></mainmatter> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>277</anchor> <rss>cat-0003.rss.xml</rss>  <addr>cat-0003</addr>  <route>cat-0003.xml</route> <date><year>2023</year> <month>9</month> <day>11</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> <contributor><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></contributor></authors> <title>Functor</title> </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb></trail> <anchor>278</anchor> <rss>cat-0002.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0002</addr>  <route>cat-0002.xml</route> <date><year>2023</year> <month>9</month> <day>11</day></date> <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>Functor</title> </frontmatter> <mainmatter><p>  Let <tex>\mathcal{C}   \to   \mathcal{D}</tex> be <link href="cat-0001.xml" type="local" title="直覺 Category">categories</link>. To specify a <em>functor</em> <tex>F</tex> from <tex>\mathcal{C}</tex> to <tex>\mathcal{D}</tex>, denoted <tex>F :  \mathcal{C}   \to   \mathcal{D}</tex>  <ol>    <li>for every object <tex>c  \in  Ob( \mathcal{C} )</tex>, one specifies an object <tex>F(c)  \in  Ob( \mathcal{D} )</tex>;</li>    <li>for every morphism <tex>f : c_1  \to  c_2</tex> in <tex>\mathcal{C}</tex>, one specifies a morphism <tex>F(f) : F(c_1)  \to  F(c_2)</tex> in <tex>\mathcal{D}</tex>.</li>  </ol>  And they must satisfy two properties:
  <ol>    <li>      for every object <tex>c  \in  Ob{ \mathcal{C} }</tex>, we have <tex>F(id_c) = id_{F(c)}</tex>;
    </li>    <li>      for every three objects <tex>c_1, c_2, c_3  \in  Ob( \mathcal{C} )</tex> and two morphisms <tex>f  \in   \mathcal{C} (c_1, c_2)</tex> and <tex>g  \in   \mathcal{C} (c_2, c_3)</tex>, the equation <tex>F(f  \circ  g) = F(f)  \circ  F(g)</tex> holds in <tex>\mathcal{D}</tex>.
    </li>  </ol></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb></trail> <anchor>279</anchor> <rss>fp-000H.rss.xml</rss>  <addr>fp-000H</addr>  <route>fp-000H.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>FP 的 Functor 與範疇論的 Functor 之間的關聯</title> </frontmatter> <mainmatter><p>  即便我們看了<link href="cat-0002.xml" type="local" title="Functor">範疇論</link>跟 FP 語言中的 Functor 定義，但在概念的銜接上仍然有困難，如果你看了 <link href="https://en.wikipedia.org/wiki/Functor_(functional_programming)" type="external">Functor(functional programming) wiki</link> 會發現他是受範疇論啟發的 design pattern。而到底引用了哪些概念，以及與語言能做到什麼程度，並沒有很好的說明。
</p><p>  如果以「Functor 是兩個範疇之間的映射」這個觀點來看程式中的 Functor 似乎有些奇怪，通常我們看到的範例都是舉兩個不同範疇 <tex>C,D</tex>，如果某一程式語言是一個範疇 <tex>C</tex> 的話，那範疇 <tex>D</tex> 就會是另一個語言，雖然我們常常這樣思考，但是我們定義程式裡面的 Functor 時不想弄得太複雜。所以這裡指的都是「 <tex>C</tex> 與 <tex>C</tex> 之間的映射」，也就是 <b>Endofunctor</b> 。你可以在 <link href="https://wiki.haskell.org/Typeclassopedia" type="external">Haskell wiki</link> 以及 fp-ts 作者所寫的 <link href="https://github.com/enricopolanski/functional-programming#a-boundary-that-leads-to-functors" type="external">Introduction to Functional Programming</link> 中找到相關說明。
</p><blockquote>  <p>Technically, these laws make f and fmap together an endofunctor on Hask, the category of Haskell types (ignoring <link href="https://wiki.haskell.org/Bottom" type="external">⊥</link>, which is a party pooper). See <link href="https://en.wikibooks.org/wiki/Haskell/Category_theory" type="external">Wikibook: Category theory</link>.</p></blockquote><blockquote>  <p>    Even though a map between two different programming languages is a fascinating idea, we're more interested in a map where C and D are the same (the TS category). In that case we're talking about <b>endofunctors</b> (from the greek &quot;endo&quot; meaning &quot;inside&quot;, &quot;internal&quot;).
  </p></blockquote><p>  範疇論跟程式語言定義的 Functor 不是完全一樣的概念，因為大部分的語言大部分的語言並不可能寫出<link href="https://ncatlab.org/nlab/show/type+of+propositions" type="external">命題</link>，所以範疇論的限制語言裡不一定有加上，這之間的一些漏洞就會產生對使用者來說可能很奇怪的結果，我們能做的就是將兩者之間重疊的部份做連結。而 Haskell 是透過 <link href="https://wiki.haskell.org/Typeclassopedia" type="external">Typeclass</link> 來做約束，所以在程式語言的語境下所說的 Functor 是指 type class 的定義。另外，我們常說「Maybe 是一個 Functor」 指的是 Maybe 是 Functor class 的一個實例 (Maybe 可替換任何其他 Functor class 實例)。
</p><p>  其他 FP 語言雖然不一定都使用 Typeclass 這個詞，但大多 Functor 的定義都差不多。
</p><block open="open"><headline><b>Haskell</b></headline> <pre>class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</pre></block><block open="open"><headline><b>Scala</b></headline> <pre>trait Functor[F[_]] {
  def map[A,B](a: F[A])(f: A =&gt; B): F[B]
}
</pre></block><block open="open"><headline><b>Lean</b></headline> <pre>class Functor (f : Type u → Type v) : Type (max (u+1) v) where
  map : {α β : Type u} → (α → β) → f α → f β
</pre></block><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>1</crumb></trail> <anchor>280</anchor> <rss>fp-000P.rss.xml</rss>  <addr>fp-000P</addr>  <route>fp-000P.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Functor Laws</title> </frontmatter> <mainmatter><p>    Functor class 的實例不能視為範疇論中的 Functor，必須檢查 Functor 的約束才會是真正的 Functor。
</p><tex display="block">fmap \  id = id
 \\ fmap \  (g \circ  f) = fmap \  g  \circ  fmap \  f
</tex></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb></trail> <anchor>281</anchor> <rss>fp-000G.rss.xml</rss>  <addr>fp-000G</addr>  <route>fp-000G.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>實際上的用途</title> </frontmatter> <mainmatter><p>	可以將一個 pure function 應用到容器型別之中。
	單純從容器的角度來看，就像是隱藏了「取出 → 運算 → 放回去」的過程，而根據每個容器用途不同在過程中執行不同操作及判斷。
</p><center><img src="resources/96e989c77602087d8405ded90a554e2a-web.svg"/></center><p>	雖然 polymorphism 的容器解釋非常方便，卻是眾多誤解的根源之一。實際上不能做這麼簡單的解釋，舉例來說我可以定義 <tex>F(-) = (c  \to  -)</tex>，於是 <tex>F(a)  \to  F(b)</tex> 視同 <tex>(c  \to  a)  \to  (c  \to  b)</tex>，令 <tex>g : c  \to  a, f : a  \to  b</tex>，<tex>\lambda  c.  \lambda  g. f(g(c))</tex> 正是一個 functor。
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb></trail> <anchor>282</anchor> <rss>fp-000I.rss.xml</rss>  <addr>fp-000I</addr>  <route>fp-000I.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>常見的 Functor Type</title> </frontmatter> <mainmatter><ul>  <li>    Maybe / Option
    <ul>      <li>Haskell (Maybe)</li>      <li>Lean (Option)</li>      <li>Rust (Option)</li>    </ul>  </li>  <li>    Either / Result / Except
    <ul>      <li>Haskell (Either)</li>      <li>Result (Rust)</li>      <li>Lean (Except)</li>    </ul>  </li>  <li>    IO
    <ul>      <li>Haskell (IO)</li>      <li>Lean (IO)</li>    </ul>  </li>  <li>    Reader
    待補
  </li>  <li>    Writer
    待補
  </li>  <li>    State
    待補
  </li></ul></mainmatter> </tree></mainmatter> </tree></context> <related><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>283</anchor> <rss>cat-0001.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0001</addr>  <route>cat-0001.xml</route> <date><year>2023</year> <month>9</month> <day>9</day></date> <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>直覺 Category</title> </frontmatter> <mainmatter><p>說直覺是因為我們這裡未有完善定義何謂 <link href="set-0001.xml" type="local" title="本性類與良性類">class</link> 跟 <link href="set-0001.xml" type="local" title="本性類與良性類">set</link>，但是作為入門或是簡要使用的定義「夠好」。
我們說 <tex>\mathcal{C}</tex> 是一個範疇的意思是：
<ol>  <li>    有 <tex>Ob( \mathcal{C} )</tex> 物件 <b>class</b>，表示範疇中的物件。作為方便的記號，當 <tex>a</tex> 為 <tex>\mathcal{C}</tex> 中一物件，我們記成 <tex>a  \in  Ob( \mathcal{C} )</tex>  </li>  <li>    當有 <tex>a, b  \in  Ob( \mathcal{C} )</tex>，而 <tex>f</tex> 為一 <tex>a</tex> 到 <tex>b</tex> 之態射(morphism) ，記為 <tex>f  \in   \mathcal{C} (a, b)</tex> 或是 <tex>f : a  \to  b</tex>。
    態射可以組合，也就是說當有 <tex>f : a  \to  b</tex> 且 <tex>g : b  \to  c</tex>，存在一個兩個的組合態射 <tex>f  \circ  g</tex>。
    與上面相同，<tex>\mathcal{C} (a, b)</tex> 是一個態射 <b>class</b>  </li>  <li>    <tex>id_a \  id_b</tex> 對 <tex>f:a \to  b</tex> 滿足 <tex>f \circ  id_a = f</tex> 跟 <tex>id_b \circ  f = f</tex>  </li>  <li>    <tex>(f \circ  g) \circ  h=f \circ  (g \circ  h)</tex>  </li></ol>  要是對每個 <tex>a,b</tex> 之間的全部 morphism <tex>\mathcal{C} (a, b)</tex> 是一個集合，就說範疇 locally small；要是整個範疇中所有的 morphism 是一個集合，那範疇就是 small。
  深入技術細節會讓你更了解為什麼需要定義這麼多東西，但在最開始的時候，只要簡單的相信範疇給定的定義即可。
</p></mainmatter> </tree></related> <backlinks><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>284</anchor> <rss>fp-000H.rss.xml</rss>  <addr>fp-000H</addr>  <route>fp-000H.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>FP 的 Functor 與範疇論的 Functor 之間的關聯</title> </frontmatter> <mainmatter><p>  即便我們看了<link href="cat-0002.xml" type="local" title="Functor">範疇論</link>跟 FP 語言中的 Functor 定義，但在概念的銜接上仍然有困難，如果你看了 <link href="https://en.wikipedia.org/wiki/Functor_(functional_programming)" type="external">Functor(functional programming) wiki</link> 會發現他是受範疇論啟發的 design pattern。而到底引用了哪些概念，以及與語言能做到什麼程度，並沒有很好的說明。
</p><p>  如果以「Functor 是兩個範疇之間的映射」這個觀點來看程式中的 Functor 似乎有些奇怪，通常我們看到的範例都是舉兩個不同範疇 <tex>C,D</tex>，如果某一程式語言是一個範疇 <tex>C</tex> 的話，那範疇 <tex>D</tex> 就會是另一個語言，雖然我們常常這樣思考，但是我們定義程式裡面的 Functor 時不想弄得太複雜。所以這裡指的都是「 <tex>C</tex> 與 <tex>C</tex> 之間的映射」，也就是 <b>Endofunctor</b> 。你可以在 <link href="https://wiki.haskell.org/Typeclassopedia" type="external">Haskell wiki</link> 以及 fp-ts 作者所寫的 <link href="https://github.com/enricopolanski/functional-programming#a-boundary-that-leads-to-functors" type="external">Introduction to Functional Programming</link> 中找到相關說明。
</p><blockquote>  <p>Technically, these laws make f and fmap together an endofunctor on Hask, the category of Haskell types (ignoring <link href="https://wiki.haskell.org/Bottom" type="external">⊥</link>, which is a party pooper). See <link href="https://en.wikibooks.org/wiki/Haskell/Category_theory" type="external">Wikibook: Category theory</link>.</p></blockquote><blockquote>  <p>    Even though a map between two different programming languages is a fascinating idea, we're more interested in a map where C and D are the same (the TS category). In that case we're talking about <b>endofunctors</b> (from the greek &quot;endo&quot; meaning &quot;inside&quot;, &quot;internal&quot;).
  </p></blockquote><p>  範疇論跟程式語言定義的 Functor 不是完全一樣的概念，因為大部分的語言大部分的語言並不可能寫出<link href="https://ncatlab.org/nlab/show/type+of+propositions" type="external">命題</link>，所以範疇論的限制語言裡不一定有加上，這之間的一些漏洞就會產生對使用者來說可能很奇怪的結果，我們能做的就是將兩者之間重疊的部份做連結。而 Haskell 是透過 <link href="https://wiki.haskell.org/Typeclassopedia" type="external">Typeclass</link> 來做約束，所以在程式語言的語境下所說的 Functor 是指 type class 的定義。另外，我們常說「Maybe 是一個 Functor」 指的是 Maybe 是 Functor class 的一個實例 (Maybe 可替換任何其他 Functor class 實例)。
</p><p>  其他 FP 語言雖然不一定都使用 Typeclass 這個詞，但大多 Functor 的定義都差不多。
</p><block open="open"><headline><b>Haskell</b></headline> <pre>class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</pre></block><block open="open"><headline><b>Scala</b></headline> <pre>trait Functor[F[_]] {
  def map[A,B](a: F[A])(f: A =&gt; B): F[B]
}
</pre></block><block open="open"><headline><b>Lean</b></headline> <pre>class Functor (f : Type u → Type v) : Type (max (u+1) v) where
  map : {α β : Type u} → (α → β) → f α → f β
</pre></block><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb></trail> <anchor>285</anchor> <rss>fp-000P.rss.xml</rss>  <addr>fp-000P</addr>  <route>fp-000P.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Functor Laws</title> </frontmatter> <mainmatter><p>    Functor class 的實例不能視為範疇論中的 Functor，必須檢查 Functor 的約束才會是真正的 Functor。
</p><tex display="block">fmap \  id = id
 \\ fmap \  (g \circ  f) = fmap \  g  \circ  fmap \  f
</tex></mainmatter> </tree></mainmatter> </tree></backlinks> <references/></backmatter></tree>