<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>666</anchor> <rss>fp-000K.rss.xml</rss> <taxon>Definition</taxon> <addr>fp-000K</addr>  <route>fp-000K.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>函數</title> </frontmatter> <mainmatter><p>在數學中，函數是一個集合 (稱為<b>定義域 domain</b>) 到另一個集合 (稱為<b>值域 codomain</b>) 的映射，假設我們有個函數 <tex>f:A  \to  B</tex>，則 <tex>A</tex> (domain) 中每個元素都必須對應到 <tex>B</tex>(codomain) 中的一個元素，能達成 <tex>A  \to  B</tex> 條件的函數總共有 <tex>|B|^{|A|}</tex> 種，我們能實現的是有限的語法能實現的一小部分，而不是所有都實現。</p><p>Typescript</p><pre>// isEven : number -&gt; boolean
function isEven(num: number): boolean {
    return num }
</pre><p>Haskell</p><pre>is_even :: Int -&gt; Bool
is_even n = n `mod` 2 == 0
</pre><p>函數分三種類型，包含 <b>單射 (injection)</b>、<b>滿射 (surjection)</b>、<b>對射 (bijection)</b>。</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb></trail> <anchor>667</anchor> <rss>fp-000L.rss.xml</rss>  <addr>fp-000L</addr>  <route>fp-000L.xml</route>   <title>單射 (injection)</title> </frontmatter> <mainmatter><p>假設我們稱一個函數 <tex>f:A  \to  B</tex> 是單射，則 <tex>A</tex> 與 <tex>B</tex> 的元素關係都是一對一的，即</p><tex display="block">\forall  a,b \in  A, \  a \neq  b  \Longrightarrow  f(a) \neq  f(b)</tex><figure>  <img src="images/fp-000L/injection.png"/>  <figcaption>injection</figcaption></figure><p>我們可以從中得知另一個訊息是 <tex>A</tex> 中的元素數量會小於等於 <tex>B</tex> 元素數量，即 <tex>|A| \le  |B|</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb></trail> <anchor>668</anchor> <rss>fp-000M.rss.xml</rss>  <addr>fp-000M</addr>  <route>fp-000M.xml</route>   <title>滿射 (surjection)</title> </frontmatter> <mainmatter><p>我們稱一個函數 <tex>f : A  \to  B</tex> 是滿射，則對於 <tex>B</tex> 中所有的元素，都存在至少一個 <tex>A</tex> 元素與其對應，即</p><tex display="block">\forall  b  \in  B, \  \exist  a  \in  A, \  f(a) = b</tex><figure>  <img src="images/fp-000M/surjection.png"/>  <figcaption>surjection</figcaption></figure><p>我們可以從中得知另一個訊息是 <tex>A</tex> 中的元素數量會大於等於 <tex>B</tex> 元素數量，即 <tex>|A|  \ge  |B|</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb></trail> <anchor>669</anchor> <rss>fp-000N.rss.xml</rss>  <addr>fp-000N</addr>  <route>fp-000N.xml</route>   <title>對射 (bijection)</title> </frontmatter> <mainmatter><p>我們稱一個函數 <tex>f : A  \to  B</tex> 是對射，則該函數同時達成單射與滿射條件，因為同時滿足 <tex>|A| \le  |B|</tex> 跟 <tex>|A| \ge  |B|</tex> 則 <tex>|A| = |B|</tex></p><figure>  <img src="images/fp-000N/bijection.png"/>  <figcaption>bijection</figcaption></figure></mainmatter> </tree></mainmatter> <backmatter><contributions/> <context/> <related/> <backlinks><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>670</anchor> <rss>fp-000J.rss.xml</rss> <taxon>Definition</taxon> <addr>fp-000J</addr>  <route>fp-000J.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>純函數 (Pure function)</title> </frontmatter> <mainmatter><p>純函數的意義是我們想讓編譯器可以做公共子常式提取跟幾種循環等最佳化而試圖去探尋的某一類函數，進而是一種有效減輕開發上的心智負擔，是能夠被靈活組合的一類函數。在程式中你可以利用函數做許多事情，不只是單純的運算，還包含了各種值的修改及各種非同步操作，雖然方便但也造成了閱讀及維護上的困難。</p><p>由於上述的最佳化都涉及到複製或是共用函數呼叫，因此可以導出這些函數在系統下的任何情形中對相同輸入都能給出相同的輸出。這個部分讓我們推導出一些性質，比如這類函數絕對不跟其他函數共用任何儲存機制，而是只用參數跟回傳處理讀寫的概念。再來函數不應該有副作用，否則增加或是減少函數呼叫都會導致不同的副作用結果。</p><p>因為程式語言裡面必須面對無法判定任意計算是否停機的關係，所以建模型的時候都會留下一個對應到 <b>undefined</b> (<tex>\bot</tex>) 的位置，這樣的概念叫做 partial function，跟數學上的<link href="fp-000K.xml" type="local" title="函數">全函數</link>有所差異。</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb></trail> <anchor>671</anchor> <rss>fp-000F.rss.xml</rss>  <addr>fp-000F</addr>  <route>fp-000F.xml</route> <date><year>2023</year> <month>10</month> <day>15</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>透過單元測試難易度辨別函式純度</title> </frontmatter> <mainmatter><p>身為一個初學者該如何知道自己的函數有多純？其實在進行單元測試時可以很容易觀察到，以下會有兩點可以注意：</p><ul>    <li>是否依賴外部資源及變數導致你需要使用 mock data？
    <br/>你必須創造一些虛假的上下文才能使你的函數正常運作，代表這函數過度依賴環境，在遷移上相對困難許多。</li>    <li>你的函數執行完是否會導致外部變數被修改？
    <br/>函數應該盡可能減少對外部影響，否則在追蹤錯誤時會變得越來越困難。</li></ul><p>除了函數本身的行為必須正確之外，一個函數無論遷移到何種新環境時都不會改變其行為，也不會對該環境產生任何影響，這個函數才稱得上足夠純。然而，在現實程式中，很難實現所有函數都是純函數的理想情況。我們能做的是盡量減少非純函數，以降低維護成本。</p><p>透過單元測試，不僅可以檢驗你的函數是否如預期執行，還可以讓你重新審視該函數的定位，並且培養撰寫純函數的直覺。</p></mainmatter> </tree></mainmatter> </tree></backlinks> <references/></backmatter></tree>