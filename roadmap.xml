<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>443</anchor> <rss>roadmap.rss.xml</rss>  <addr>roadmap</addr>  <route>roadmap.xml</route>   <title>地圖</title> <meta name="author">false</meta></frontmatter> <mainmatter><p>此地圖為一大方向，每個主體內會有延伸，包含實例、名詞解釋等等，類似於心智圖，而未來也有可能異動</p><ol><li>lambda calculus</li>
    <li>用 recursion 解釋可計算性</li>
    <li>加上 simply type</li>
    <li>解釋型別規則</li>
    <li>建立 STLC categorical semantic</li>
    <li>加上 polymorphism</li>
    <li>解釋型別規則</li>
    <li>建立 <tex>E  \to  B</tex> categorical semantic</li>
    <li>解釋 <tex>\lambda  2</tex> 的 polymorphic property</li>
    <li>解釋 recursive type</li>
    <li>連結 F-algebra</li>
    <li>變成 dependent type</li>
    <li>解釋型別規則</li>
    <li>解釋模型（The natural model）
        <ul><li>topos</li>
            <li>topos fundamental theorem</li>
            <li>presheaf</li>
            <li>representable natural transformation</li></ul></li>
    <li>進入真正的應用</li>
    <li>side effect</li>
    <li>concurrency</li>
    <li>安全性

        <ul><li>記憶體安全與子結構類型</li>
                <ul><li>(?) proof nets</li></ul>
            <li>整體安全性不是只關乎記憶體</li></ul></li>
    <li>domain language</li></ol></mainmatter> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="true"><frontmatter><anchor>444</anchor> <rss>index.rss.xml</rss>  <addr>fp-0001</addr>  <route>index.xml</route>   <title>帶你入門 functional programming</title> <meta name="author">false</meta></frontmatter> <mainmatter><p>什麼是函數式程式設計是一個大哉問，但作為一個入門導引，我們簡單的定義成受 lambda calculus 啟發，並且格外注重可組合性的語言。在其上有兩種變體</p><ol><li>一種現在相當著重在對形式計算時機的控制，也就是 macro 上，也就是 Lisp 與其延伸語言</li>
  <li>一種則注重對數學概念的引進，乃自裡面有一種叫做代數類型的型別定義方法，其基本出發自 F-algebra，但其內涵相當深遠，並不止於此，例如定理證明器往往只使用其中的 inductives 這一類變體。</li></ol><p>作為入門網站，這裡著重在第二類語言，因為 macro 與這類語言並沒有顯著衝突，並且也非入門概念，引進理論討論 macro 的運算控制也沒有問題，因此沒有理由特別用入門時的觀點分類。那麼，第二類語言裡面，同樣有許多著重不同的變體</p><ol><li>OCaml 著重類型正確，卻不在意 side effect</li>
  <li>Haskell 注重類型也注重 side effect 控制，同時對 type level 有一定的操作能力</li>
  <li>Agda, Coq, Lean 等語言作為寫程式的工具可能有點失格，但主要是因為目標完全不同，分類作語言的子類別：定理證明器 比較合適</li></ol><p>這個網站的準則，是教導抽象的數學概念，讓學習者最終對實際 functional programming 有一定的了解，並大致理解現代語義學研究，或許能夠應用其成果。那麼，我們開始回顧 lambda calculus 與可計算性的沿革，開始學習 functional programming 吧</p></mainmatter> </tree></context> <related/> <backlinks/> <references/></backmatter></tree>