<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>410</anchor> <rss>fp-000G.rss.xml</rss>  <addr>fp-000G</addr>  <route>fp-000G.xml</route>  <authors><author>fizzyelt</author><author>dannypsnl</author> </authors> <title>實際上的用途</title> </frontmatter> <mainmatter><p>	可以將一個 pure function 應用到容器型別之中。
	單純從容器的角度來看，就像是隱藏了「取出 → 運算 → 放回去」的過程，而根據每個容器用途不同在過程中執行不同操作及判斷。
</p><center><img src="resources/96e989c77602087d8405ded90a554e2a-web.svg"/></center><p>	雖然 polymorphism 的容器解釋非常方便，卻是眾多誤解的根源之一。實際上不能做這麼簡單的解釋，舉例來說我可以定義 <tex>F(-) = (c  \to  -)</tex>，於是 <tex>F(a)  \to  F(b)</tex> 視同 <tex>(c  \to  a)  \to  (c  \to  b)</tex>，令 <tex>g : c  \to  a, f : a  \to  b</tex>，<tex>\lambda  c.  \lambda  g. f(g(c))</tex> 正是一個 functor。
</p></mainmatter> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>411</anchor> <rss>fp-000F.rss.xml</rss>  <addr>fp-000F</addr>  <route>fp-000F.xml</route> <date><year>2023</year> <month>9</month> <day>11</day></date> <authors><author>fizzyelt</author> <contributor>dannypsnl</contributor></authors> <title>Functor</title> </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb></trail> <anchor>412</anchor> <rss>cat-0002.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0002</addr>  <route>cat-0002.xml</route> <date><year>2023</year> <month>9</month> <day>11</day></date> <authors><author>dannypsnl</author> </authors> <title>Functor</title> </frontmatter> <mainmatter><p>  Let <tex>\mathcal{C}   \to   \mathcal{D}</tex> be <link href="cat-0001.xml" type="local" title="直覺 Category">categories</link>. To specify a <em>functor</em> <tex>F</tex> from <tex>\mathcal{C}</tex> to <tex>\mathcal{D}</tex>, denoted <tex>F :  \mathcal{C}   \to   \mathcal{D}</tex>  <ol>    <li>for every object <tex>c  \in  Ob( \mathcal{C} )</tex>, one specifies an object <tex>F(c)  \in  Ob( \mathcal{D} )</tex>;</li>    <li>for every morphism <tex>f : c_1  \to  c_2</tex> in <tex>\mathcal{C}</tex>, one specifies a morphism <tex>F(f) : F(c_1)  \to  F(c_2)</tex> in <tex>\mathcal{D}</tex>.</li>  </ol>  And they must satisfy two properties:
  <ol>    <li>      for every object <tex>c  \in  Ob{ \mathcal{C} }</tex>, we have <tex>F(id_c) = id_{F(c)}</tex>;
    </li>    <li>      for every three objects <tex>c_1, c_2, c_3  \in  Ob( \mathcal{C} )</tex> and two morphisms <tex>f  \in   \mathcal{C} (c_1, c_2)</tex> and <tex>g  \in   \mathcal{C} (c_2, c_3)</tex>, the equation <tex>F(f  \circ  g) = F(f)  \circ  F(g)</tex> holds in <tex>\mathcal{D}</tex>.
    </li>  </ol></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb></trail> <anchor>413</anchor> <rss>fp-000G.rss.xml</rss>  <addr>fp-000G</addr>  <route>fp-000G.xml</route>  <authors><author>fizzyelt</author><author>dannypsnl</author> </authors> <title>實際上的用途</title> </frontmatter> <mainmatter><p>	可以將一個 pure function 應用到容器型別之中。
	單純從容器的角度來看，就像是隱藏了「取出 → 運算 → 放回去」的過程，而根據每個容器用途不同在過程中執行不同操作及判斷。
</p><center><img src="resources/96e989c77602087d8405ded90a554e2a-web.svg"/></center><p>	雖然 polymorphism 的容器解釋非常方便，卻是眾多誤解的根源之一。實際上不能做這麼簡單的解釋，舉例來說我可以定義 <tex>F(-) = (c  \to  -)</tex>，於是 <tex>F(a)  \to  F(b)</tex> 視同 <tex>(c  \to  a)  \to  (c  \to  b)</tex>，令 <tex>g : c  \to  a, f : a  \to  b</tex>，<tex>\lambda  c.  \lambda  g. f(g(c))</tex> 正是一個 functor。
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb></trail> <anchor>414</anchor> <rss>fp-000H.rss.xml</rss>  <addr>fp-000H</addr>  <route>fp-000H.xml</route>  <authors><author>fizzyelt</author> </authors> <title>Lean 中的定義</title> </frontmatter> <mainmatter><pre>class Functor (f : Type u → Type v) : Type (max (u+1) v) where
  map : {α β : Type u} → (α → β) → f α → f β
  mapConst : {α β : Type u} → α → f β → f α :=
    Function.comp map (Function.const _)
</pre><link href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Functor" type="external">Lean doc: Functor</link></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb></trail> <anchor>415</anchor> <rss>fp-000I.rss.xml</rss>  <addr>fp-000I</addr>  <route>fp-000I.xml</route>  <authors><author>fizzyelt</author> </authors> <title>常見的 Functor Type</title> </frontmatter> <mainmatter><ul>  <li>    Maybe / Option
    <ul>      <li>Haskell (Maybe)</li>      <li>Lean (Option)</li>      <li>Rust (Option)</li>    </ul>  </li>  <li>    Either / Result / Except
    <ul>      <li>Haskell (Either)</li>      <li>Result (Rust)</li>      <li>Lean (Except)</li>    </ul>  </li>  <li>    IO
    <ul>      <li>Haskell (IO)</li>      <li>Lean (IO)</li>    </ul>  </li>  <li>    Reader
    待補
  </li>  <li>    Writer
    待補
  </li>  <li>    State
    待補
  </li></ul></mainmatter> </tree></mainmatter> </tree></context> <related/> <backlinks/> <references/></backmatter></tree>