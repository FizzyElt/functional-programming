<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>235</anchor> <rss>cat-0009.rss.xml</rss>  <addr>cat-0009</addr>  <route>cat-0009.xml</route>  <authors><author><link href="dannypsnl.xml" type="local" dannypsnl="addr">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local" fizzyelt="addr">FizzyElt</link></author> </authors> <title>Catamorphism</title> </frontmatter> <mainmatter><p>根據 Lambek's 理論可以畫出交換圖</p><img src="resources/dda80e138546babbb1220c2087f88e8d.svg"/><p>在 Haskell 中，我們可以這樣定義初始代數</p><block open="open"><headline><strong>Haskell</strong></headline> <pre>newtype Fix f = Fix (f (Fix f))

unFix :: Fix f -&gt; f (Fix f)
unFix (Fix x) = x
</pre></block><p>將 <tex>j</tex> 視為 <code>Fix</code> 建構子，<tex>j^{-1}</tex> 為 <code>unFix</code>，再來我們可以定義 <code>m = alg . fmap m . unFix</code>。因為 <code>m :: Fix f -&gt; a</code>，我們有了 Catamorphism 的程式定義</p><block open="open"><headline><strong>Haskell</strong></headline> <pre>cata :: Functor f =&gt; (f a -&gt; a) -&gt; Fix f -&gt; a
cata alg = alg . fmap (cata alg) . unFix
</pre></block><p><code>foldr</code> 是一個常見的例子，它是 Catamorphism 的一種便利版本。</p></mainmatter> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" numbered="false" root="false"><frontmatter><anchor>236</anchor> <rss>cat-0005.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0005</addr>  <route>cat-0005.xml</route>  <authors><author><link href="dannypsnl.xml" type="local" dannypsnl="addr">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local" fizzyelt="addr">FizzyElt</link></author> </authors> <title><tex>F</tex>-algebra</title> </frontmatter> <mainmatter><p>要理解 <tex>F</tex>-algebra，我們需要一些觀察，第一個是代數可以表示成一組簽名。例如，Monoid 有一組簽名：</p><tex display="block">\begin {cases}
1:1 \to  m  \\ 
 \bullet : m  \times  m  \to  m
 \end {cases}</tex><p>或者你可以將 環（Ring）寫成：</p><tex display="block">\begin {cases}
0: 1  \to  m  \\ 
1:1  \to  m  \\ 
+: m  \times  m  \to  m  \\ 
 \times : m  \times  m  \to  m  \\ 
- : m  \to  m
 \end {cases}</tex><p>我們令 <tex>m</tex> 為範疇 <tex>C</tex> 中的一個 object，要選一個足以表示簽名的範疇，以上面的例子來說需要 <link href="cat-0004.xml" type="local" addr="cat-0004" title="Cartesian closed category">cartesian closed category</link>。</p><ul><li>對 <tex>m</tex> 來說，Monoid 是 <tex>C</tex> 中的一個態射 <tex>1 + m  \times  m  \to  m</tex></li>
<li>對 <tex>m</tex> 來說，環是 <tex>C</tex> 中的一個態射 <tex>1 + 1 + m  \times  m + m  \times  m + m  \to  m</tex></li></ul><p>根據這些，我們把代數的定義推廣為：固定 <tex>F</tex> 函子後，每個 <tex>F(m)  \to  m</tex> 都是一個代數。</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>237</anchor> <rss>cat-0006.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0006</addr>  <route>cat-0006.xml</route>  <authors><author><link href="dannypsnl.xml" type="local" dannypsnl="addr">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local" fizzyelt="addr">FizzyElt</link></author> </authors> <title><tex>F</tex>-algebra (algebra for an endofunctor)</title> </frontmatter> <mainmatter><p>在一個適當的範疇 <tex>C</tex> 中，我們把簽名改成一個 functor <tex>F</tex>，這個函子投射出的 <tex>F(m)  \to  m</tex> 是 <tex>F</tex>-algebra，記為三元組：</p><tex display="block">(F,x, \alpha )</tex><p>其中 <tex>\alpha  : Fx  \to  x</tex> 是一個 <tex>C</tex> 中的態射。</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>238</anchor> <rss>cat-0007.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0007</addr>  <route>cat-0007.xml</route>  <authors><author><link href="dannypsnl.xml" type="local" dannypsnl="addr">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local" fizzyelt="addr">FizzyElt</link></author> </authors> <title>Category of <tex>F</tex>-algebra</title> </frontmatter> <mainmatter><p>functor 與 natural transformation 構成 functor category</p><p>對於在一個適當的範疇 <tex>C</tex> 中固定的自函子 <tex>F</tex> (以下省略 <tex>F</tex> 符號)</p><ol><li>object 是全部的 <tex>F</tex>-algebra。</li>
    <li>態射皆為 <tex>(x, \alpha ) \xrightarrow {Fm} (y, \beta )</tex> 對象的同態，組合由函子定律給出。</li></ol><p>同態是令下圖交換的態射 <tex>m</tex></p><img src="resources/bb538e036773c27d46a939fe9fe29cc2.svg"/><p>額外檢查我們可以發現 identity 也如預期運作</p><img src="resources/cdb83e24b918c80c9020034a27b05ac2.svg"/></mainmatter> </tree><p>這些是跟範疇中初始對象 (initial object) 有關的一個定理</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>239</anchor> <rss>cat-0008.rss.xml</rss> <taxon>Theorem</taxon> <addr>cat-0008</addr>  <route>cat-0008.xml</route>  <authors><author><link href="dannypsnl.xml" type="local" dannypsnl="addr">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local" fizzyelt="addr">FizzyElt</link></author> </authors> <title>Lambek's</title> </frontmatter> <mainmatter><p>初始代數是同構態射</p><block open="open"><headline><strong>證明</strong></headline> 
讓 <tex>Fi</tex> 成為 <tex>F</tex>-algebra 範疇中的初始對象，對於 <tex>C</tex> 中所有對象 <tex>a</tex> 產生以下交換圖
</block><img src="resources/69bc9e027f5f8f3596a281672f1e0f44.svg"/><p>現在我們將 <tex>a</tex> 替換成 <tex>Fi</tex></p><img src="resources/48cfd2934f84f23b4ed2b84e8991e5b1.svg"/><p>再來透過複製路徑 <tex>Fi  \to  i</tex> 得出以下交換圖</p><img src="resources/4863987a68e7a30822bf3b1297687d9c.svg"/><p>將兩張交換圖合併</p><img src="resources/8aea8ffa62f22dcbc3c9b79cf9b4276f.svg"/><p>透過定義，我們現在知道 <tex>j  \circ  m</tex> 是同態(homomorphism)，並且因為 <tex>Fi</tex> 為初始對象我們得到</p><tex display="block">Fj  \circ  Fm = 1_{Fi}</tex><p>所以，我們也得出</p><tex display="block">j  \circ  m = 1_{i}</tex><p>因此 <tex>m</tex> 是 <tex>j</tex> 的 inverse，證明 <tex>j</tex> 是同構。</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" numbered="true" root="false"><frontmatter><anchor>240</anchor> <rss>cat-000A.rss.xml</rss>  <addr>cat-000A</addr>  <route>cat-000A.xml</route>  <authors><author><link href="dannypsnl.xml" type="local" dannypsnl="addr">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local" fizzyelt="addr">FizzyElt</link></author> </authors> <title>Anamorphism</title> </frontmatter> <mainmatter><p>作為一個對偶概念，可以畫出一個 coalgebra 的圖，我們稱這種關係為 anamorphism。</p><img src="resources/7fb622e82d4208ed34ae423feb3d278f.svg"/></mainmatter> </tree></mainmatter> </tree></context> <related/> <backlinks/> <references/></backmatter></tree>