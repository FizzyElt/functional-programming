<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>403</anchor> <rss>fizzyelt.rss.xml</rss> <taxon>Person</taxon> <addr>fizzyelt</addr>  <route>fizzyelt.xml</route>   <title>FizzyElt</title> <meta name="position">Front-End Developer</meta><meta name="external">https://fizzyelt.github.io</meta></frontmatter> <mainmatter/> <backmatter><contributions><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>404</anchor> <rss>fp-000F.rss.xml</rss>  <addr>fp-000F</addr>  <route>fp-000F.xml</route> <date><year>2023</year> <month>10</month> <day>15</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>透過單元測試難易度辨別函式純度</title> </frontmatter> <mainmatter><p>身為一個初學者該如何知道自己的函數有多純？其實在進行單元測試時可以很容易觀察到，以下會有兩點可以注意：</p><ul><li>是否依賴外部資源及變數導致你需要使用 mock data？
    <br/>你必須創造一些虛假的上下文才能使你的函數正常運作，代表這函數過度依賴環境，在遷移上相對困難許多。</li>

    <li>你的函數執行完是否會導致外部變數被修改？
    <br/>函數應該盡可能減少對外部影響，否則在追蹤錯誤時會變得越來越困難。</li></ul><p>除了函數本身的行為必須正確之外，一個函數無論遷移到何種新環境時都不會改變其行為，也不會對該環境產生任何影響，這個函數才稱得上足夠純。然而，在現實程式中，很難實現所有函數都是純函數的理想情況。我們能做的是盡量減少非純函數，以降低維護成本。</p><p>透過單元測試，不僅可以檢驗你的函數是否如預期執行，還可以讓你重新審視該函數的定位，並且培養撰寫純函數的直覺。</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>405</anchor> <rss>alg-0001.rss.xml</rss> <taxon>Definition</taxon> <addr>alg-0001</addr>  <route>alg-0001.xml</route> <date><year>2023</year> <month>9</month> <day>13</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> <contributor><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></contributor></authors> <title>Magma</title> </frontmatter> <mainmatter><p><link href="https://ncatlab.org/nlab/show/magma" type="external">Magma</link> 是代數結構的一種，由一個集合與運算子組成 <tex>(M, \  \bullet )</tex>。定義為「對於在集合 <tex>M</tex> 裡所有 <tex>a, \  b</tex>，<tex>a \  \bullet   \  b</tex> 的結果也是集合 <tex>M</tex> 裡的元素」</p><tex display="block">
 a, \  b  \in  M  \Longrightarrow  a \  \bullet \  b  \in  M
</tex><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb></trail> <anchor>406</anchor> <rss>alg-0002.rss.xml</rss> <taxon>Example</taxon> <addr>alg-0002</addr>  <route>alg-0002.xml</route> <date><year>2023</year> <month>9</month> <day>13</day></date> <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>不是 semigroup 的 magma</title> </frontmatter> <mainmatter><p>我們很容易造出一堆其實是 semigroup（滿足結合律）的 magma，然後騙自己說這樣就是 magma，但這無助於我們思考結合律的意義。刻意構造一個 magma 會發現這其實沒那麼容易，這裡給出一個是 magma 但不是 semigroup 的案例。</p><ol><li><tex>M</tex> 是整數有序對構成的集合
  </li>
  <li><tex>\bullet</tex> 在輸入兩對的相接序對有序時直接回傳，在無序時回傳全部元素的總和為唯一元素的有序對
  </li></ol><p>第二條彎彎繞繞的意思就是 <tex>[1]  \bullet  [2] = [1, 2]</tex>，而 <tex>[2]  \bullet  [1] = [3]</tex>。所以現在可以說結合律對運算 <tex>\bullet</tex> 不成立，因為</p><ul><li><tex>[0]  \bullet  ([2]  \bullet  [1]) = [0,3]</tex></li>
  <li><tex>([0]  \bullet  [2])  \bullet  [1] = [3]</tex></li></ul><p>也可以看到交換律不成立的例子。</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>407</anchor> <rss>alg-0005.rss.xml</rss> <taxon>Definition</taxon> <addr>alg-0005</addr>  <route>alg-0005.xml</route> <date><year>2023</year> <month>9</month> <day>13</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> <contributor><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></contributor></authors> <title>Monoid</title> </frontmatter> <mainmatter><p><link href="https://en.wikipedia.org/wiki/Monoid" type="external">Monoid</link> 是有 identity element 的 <link href="alg-0003.xml" type="local" title="Semigroup">semigroup</link>，其中 identity element <tex>e</tex> 滿足</p><tex display="block">
  e  \bullet  a = a = a  \bullet  e
</tex><p>如果把 id morphism 對應到 <tex>e</tex>，而剩餘的 morphism 對應到每個 monoid 的元素上，那麼只有一個 object 的 <link href="cat-0001.xml" type="local" title="直覺 Category">small category</link> 正好是一個 monoid。</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb></trail> <anchor>408</anchor> <rss>fp-000O.rss.xml</rss> <taxon>Example</taxon> <addr>fp-000O</addr>  <route>fp-000O.xml</route> <date><year>2023</year> <month>9</month> <day>13</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>函數組合</title> </frontmatter> <mainmatter><p>在禁止 free variable 的 lambda calculus 中，可以將 monoid 用作模型</p><ul><li><tex>e</tex> 就是 <tex>\lambda  x. x</tex></li>
  <li>函數 <tex>f, g</tex> 的組合 <tex>f  \circ  g</tex> 是 <tex>\lambda  x. f (g  \;  x)</tex></li></ul><p>identity law 的檢查比較容易，這裡我們就來看結合律如何運作：</p><tex display="block">\begin {aligned}
  &amp;f  \circ  (g  \circ  h)
   \\ 
  &amp;=  \lambda  x. f ((g  \circ  h)  \;  x)
   \\ 
  &amp;=  \lambda  x. f (( \lambda  x. g (h  \;  x))  \;  x)
   \\ 
  &amp;=  \lambda  x. f (g (h  \;  x))
 \\ 
  &amp;(f  \circ  g)  \circ  h
   \\ 
  &amp;=  \lambda  x. (f  \circ  g)(h  \;  x)
   \\ 
  &amp;=  \lambda  x. ( \lambda  x. f (g  \;  x)) (h  \;  x)
   \\ 
  &amp;=  \lambda  x. f (g (h  \;  x))
 \end {aligned}</tex><p>確實滿足要求。</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb></trail> <anchor>409</anchor> <rss>cs-0001.rss.xml</rss> <taxon>Example</taxon> <addr>cs-0001</addr>  <route>cs-0001.xml</route> <date><year>2023</year> <month>9</month> <day>13</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>半自動機</title> </frontmatter> <mainmatter><p>對給定的半自動機可以討論其 <link href="https://planetmath.org/CharacteristicMonoid" type="external">characteristic monoid</link>。一個半自動機是個三元組 <tex>(Q,  \Sigma , T)</tex></p><ul><li><tex>Q</tex> 是一個非空的「狀態集合」</li>
  <li><tex>\Sigma</tex> 是一個「輸入字母表」的非空集合</li>
  <li><tex>T</tex> 是轉移函數</li></ul><p>假設一個 <tex>M(Q,  \Sigma , T)</tex> 集合</p><tex display="block">
  M(Q, \  \Sigma , \  T) =  \{  T_w \  | \  w \in   \Sigma ^*  \} 
</tex><p>集合 <tex>M(Q, \  \Sigma , \  T)</tex> 在<strong>函數複合</strong>下閉合；就是說，對於所有 <tex>v,w  \in   \Sigma ^*</tex> ，有 <tex>T_w  \circ  T_v = T_{vw}</tex> 。它還包含 <tex>T_ \epsilon</tex> ，而這個 <tex>T_ \epsilon</tex> 是個<strong>恆等函數(即 identity function)</strong>。 </p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>410</anchor> <rss>alg-0003.rss.xml</rss> <taxon>Definition</taxon> <addr>alg-0003</addr>  <route>alg-0003.xml</route> <date><year>2023</year> <month>9</month> <day>13</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> <contributor><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></contributor></authors> <title>Semigroup</title> </frontmatter> <mainmatter><p><link href="https://ncatlab.org/nlab/show/semigroup" type="external">Semigroup</link> 是滿足結合律的 <link href="alg-0001.xml" type="local" title="Magma">Magma</link>。結合律是指對所有 semigroup 中的元素 <tex>x,y,z  \in  S</tex>，皆滿足</p><tex display="block">
  x  \bullet  (y  \bullet  z) = (x  \bullet  y)  \bullet  z
</tex><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb></trail> <anchor>411</anchor> <rss>alg-0004.rss.xml</rss> <taxon>Example</taxon> <addr>alg-0004</addr>  <route>alg-0004.xml</route> <date><year>2023</year> <month>9</month> <day>13</day></date> <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>不滿足交換律的 semigroup</title> </frontmatter> <mainmatter><p>沿襲 <link href="alg-0002.xml" type="local" title="不是 semigroup 的 magma">Magma 案例</link>的傳統，這裡不舉滿足交換律的 semigroup。在程式語言裡面已經有一個我們很常看到的案例了，也就是字串相接，我們可以著手檢查：</p><ul><li>字串與字串相接還是字串</li>
  <li>字串先接 <tex>x, y</tex> 或 <tex>y, z</tex> 不影響結果</li></ul></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>412</anchor> <rss>fp-000O.rss.xml</rss> <taxon>Example</taxon> <addr>fp-000O</addr>  <route>fp-000O.xml</route> <date><year>2023</year> <month>9</month> <day>13</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>函數組合</title> </frontmatter> <mainmatter><p>在禁止 free variable 的 lambda calculus 中，可以將 monoid 用作模型</p><ul><li><tex>e</tex> 就是 <tex>\lambda  x. x</tex></li>
  <li>函數 <tex>f, g</tex> 的組合 <tex>f  \circ  g</tex> 是 <tex>\lambda  x. f (g  \;  x)</tex></li></ul><p>identity law 的檢查比較容易，這裡我們就來看結合律如何運作：</p><tex display="block">\begin {aligned}
  &amp;f  \circ  (g  \circ  h)
   \\ 
  &amp;=  \lambda  x. f ((g  \circ  h)  \;  x)
   \\ 
  &amp;=  \lambda  x. f (( \lambda  x. g (h  \;  x))  \;  x)
   \\ 
  &amp;=  \lambda  x. f (g (h  \;  x))
 \\ 
  &amp;(f  \circ  g)  \circ  h
   \\ 
  &amp;=  \lambda  x. (f  \circ  g)(h  \;  x)
   \\ 
  &amp;=  \lambda  x. ( \lambda  x. f (g  \;  x)) (h  \;  x)
   \\ 
  &amp;=  \lambda  x. f (g (h  \;  x))
 \end {aligned}</tex><p>確實滿足要求。</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>413</anchor> <rss>cs-0001.rss.xml</rss> <taxon>Example</taxon> <addr>cs-0001</addr>  <route>cs-0001.xml</route> <date><year>2023</year> <month>9</month> <day>13</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>半自動機</title> </frontmatter> <mainmatter><p>對給定的半自動機可以討論其 <link href="https://planetmath.org/CharacteristicMonoid" type="external">characteristic monoid</link>。一個半自動機是個三元組 <tex>(Q,  \Sigma , T)</tex></p><ul><li><tex>Q</tex> 是一個非空的「狀態集合」</li>
  <li><tex>\Sigma</tex> 是一個「輸入字母表」的非空集合</li>
  <li><tex>T</tex> 是轉移函數</li></ul><p>假設一個 <tex>M(Q,  \Sigma , T)</tex> 集合</p><tex display="block">
  M(Q, \  \Sigma , \  T) =  \{  T_w \  | \  w \in   \Sigma ^*  \} 
</tex><p>集合 <tex>M(Q, \  \Sigma , \  T)</tex> 在<strong>函數複合</strong>下閉合；就是說，對於所有 <tex>v,w  \in   \Sigma ^*</tex> ，有 <tex>T_w  \circ  T_v = T_{vw}</tex> 。它還包含 <tex>T_ \epsilon</tex> ，而這個 <tex>T_ \epsilon</tex> 是個<strong>恆等函數(即 identity function)</strong>。 </p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>414</anchor> <rss>cat-0003.rss.xml</rss>  <addr>cat-0003</addr>  <route>cat-0003.xml</route> <date><year>2023</year> <month>9</month> <day>11</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> <contributor><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></contributor></authors> <title>Functor</title> </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb></trail> <anchor>415</anchor> <rss>cat-0002.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0002</addr>  <route>cat-0002.xml</route> <date><year>2023</year> <month>9</month> <day>11</day></date> <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>Functor</title> </frontmatter> <mainmatter><p>
  Let <tex>\mathcal {C}   \to   \mathcal {D}</tex> be <link href="cat-0001.xml" type="local" title="直覺 Category">categories</link>. To specify a <em>functor</em> <tex>F</tex> from <tex>\mathcal {C}</tex> to <tex>\mathcal {D}</tex>, denoted <tex>F :  \mathcal {C}   \to   \mathcal {D}</tex>

  <ol><li>for every object <tex>c  \in  Ob( \mathcal {C} )</tex>, one specifies an object <tex>F(c)  \in  Ob( \mathcal {D} )</tex>;</li>
    <li>for every morphism <tex>f : c_1  \to  c_2</tex> in <tex>\mathcal {C}</tex>, one specifies a morphism <tex>F(f) : F(c_1)  \to  F(c_2)</tex> in <tex>\mathcal {D}</tex>.</li></ol>

  And they must satisfy two properties:

  <ol><li>
      for every object <tex>c  \in  Ob( \mathcal {C} )</tex>, we have <tex>F(id_c) = id_{F(c)}</tex>;
    </li>
    <li>
      for every three objects <tex>c_1, c_2, c_3  \in  Ob( \mathcal {C} )</tex> and two morphisms <tex>f  \in   \mathcal {C} (c_1, c_2)</tex> and <tex>g  \in   \mathcal {C} (c_2, c_3)</tex>, the equation <tex>F(f  \circ  g) = F(f)  \circ  F(g)</tex> holds in <tex>\mathcal {D}</tex>.
    </li></ol></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb></trail> <anchor>416</anchor> <rss>fp-000H.rss.xml</rss>  <addr>fp-000H</addr>  <route>fp-000H.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>FP 的 Functor 與範疇論的 Functor 之間的關聯</title> </frontmatter> <mainmatter><p>
  即便我們看了<link href="cat-0002.xml" type="local" title="Functor">範疇論</link>跟 FP 語言中的 Functor 定義，但在概念的銜接上仍然有困難，如果你看了 <link href="https://en.wikipedia.org/wiki/Functor_(functional_programming)" type="external">Functor(functional programming) wiki</link> 會發現他是受範疇論啟發的 design pattern。而到底引用了哪些概念，以及與語言能做到什麼程度，並沒有很好的說明。
</p><p>
  如果以「Functor 是兩個範疇之間的映射」這個觀點來看程式中的 Functor 似乎有些奇怪，通常我們看到的範例都是舉兩個不同範疇 <tex>C,D</tex>，如果某一程式語言是一個範疇 <tex>C</tex> 的話，那範疇 <tex>D</tex> 就會是另一個語言，雖然我們常常這樣思考，但是我們定義程式裡面的 Functor 時不想弄得太複雜。所以這裡指的都是「 <tex>C</tex> 與 <tex>C</tex> 之間的映射」，也就是 <strong>Endofunctor</strong> 。你可以在 <link href="https://wiki.haskell.org/Typeclassopedia" type="external">Haskell wiki</link> 以及 fp-ts 作者所寫的 <link href="https://github.com/enricopolanski/functional-programming#a-boundary-that-leads-to-functors" type="external">Introduction to Functional Programming</link> 中找到相關說明。
</p><blockquote><p>Technically, these laws make f and fmap together an endofunctor on Hask, the category of Haskell types (ignoring <link href="https://wiki.haskell.org/Bottom" type="external">⊥</link>, which is a party pooper). See <link href="https://en.wikibooks.org/wiki/Haskell/Category_theory" type="external">Wikibook: Category theory</link>.</p></blockquote><blockquote><p>
    Even though a map between two different programming languages is a fascinating idea, we're more interested in a map where C and D are the same (the TS category). In that case we're talking about <strong>endofunctors</strong> (from the greek &quot;endo&quot; meaning &quot;inside&quot;, &quot;internal&quot;).
  </p></blockquote><p>
  範疇論跟程式語言定義的 Functor 不是完全一樣的概念，因為大部分的語言並不可能寫出<link href="https://ncatlab.org/nlab/show/type+of+propositions" type="external">命題</link>，所以範疇論的限制語言裡不一定有加上，這之間的一些漏洞就會產生對使用者來說可能很奇怪的結果，我們能做的就是將兩者之間重疊的部份做連結。而 Haskell 是透過 <link href="https://wiki.haskell.org/Typeclassopedia" type="external">Typeclass</link> 來做約束，所以在程式語言的語境下所說的 Functor 是指 type class 的定義。另外，我們常說「Maybe 是一個 Functor」 指的是 Maybe 是 Functor class 的一個實例 (Maybe 可替換任何其他 Functor class 實例)。
</p><p>
  其他 FP 語言雖然不一定都使用 Typeclass 這個詞，但大多 Functor 的定義都差不多。
</p><block open="open"><headline><strong>Haskell</strong></headline> 
<pre>class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</pre>
</block><block open="open"><headline><strong>Scala</strong></headline> 
<pre>trait Functor[F[_]] {
  def map[A,B](a: F[A])(f: A =&gt; B): F[B]
}
</pre>
</block><block open="open"><headline><strong>Lean</strong></headline> 
<pre>class Functor (f : Type u → Type v) : Type (max (u+1) v) where
  map : {α β : Type u} → (α → β) → f α → f β
</pre>
</block><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb> <crumb>1</crumb></trail> <anchor>417</anchor> <rss>fp-000P.rss.xml</rss>  <addr>fp-000P</addr>  <route>fp-000P.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Functor Laws</title> </frontmatter> <mainmatter><p>
    Functor class 的實例不能視為範疇論中的 Functor，必須檢查 Functor 的約束才會是真正的 Functor。
</p><tex display="block">
fmap \  id = id
 \\ 
fmap \  (g \circ  f) = fmap \  g  \circ  fmap \  f
</tex></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>7</crumb></trail> <anchor>418</anchor> <rss>fp-000G.rss.xml</rss>  <addr>fp-000G</addr>  <route>fp-000G.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>實際上的用途</title> </frontmatter> <mainmatter><p>
	可以將一個 pure function 應用到容器型別之中。
	單純從容器的角度來看，就像是隱藏了「取出 → 運算 → 放回去」的過程，而根據每個容器用途不同在過程中執行不同操作及判斷。
</p><img src="resources/c153deb1fe8bd64db16ba299c55cf845-web.svg"/><p>
	雖然 polymorphism 的容器解釋非常方便，卻是眾多誤解的根源之一。實際上不能做這麼簡單的解釋，舉例來說我可以定義 <tex>F(-) = (c  \to  -)</tex>，於是 <tex>F(a)  \to  F(b)</tex> 視同 <tex>(c  \to  a)  \to  (c  \to  b)</tex>，令 <tex>g : c  \to  a, f : a  \to  b</tex>，<tex>\lambda  c.  \lambda  g. f(g(c))</tex> 正是一個 functor。
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb></trail> <anchor>419</anchor> <rss>fp-000I.rss.xml</rss>  <addr>fp-000I</addr>  <route>fp-000I.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>常見的 Functor Type</title> </frontmatter> <mainmatter><ul><li>
    Maybe / Option
    <ul><li>Haskell (Maybe)</li>
      <li>Lean (Option)</li>
      <li>Rust (Option)</li></ul></li>
  <li>
    Either / Result / Except
    <ul><li>Haskell (Either)</li>
      <li>Result (Rust)</li>
      <li>Lean (Except)</li></ul></li>
  <li>
    IO
    <ul><li>Haskell (IO)</li>
      <li>Lean (IO)</li></ul></li>

  <li>
    Reader
    待補
  </li>
  <li>
    Writer
    待補
  </li>
  <li>
    State
    待補
  </li></ul></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>420</anchor> <rss>fp-0002.rss.xml</rss>  <addr>fp-0002</addr>  <route>fp-0002.xml</route> <date><year>2023</year> <month>9</month> <day>9</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Data first or Data last?</title> </frontmatter> <mainmatter><p>
  data first 跟 data last 區別在於主要被操作的資料是擺在最前面或最後面，而 functional programming 習慣 data last 的方式設計函數，目的是提高函數的可組合性。
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb></trail> <anchor>421</anchor> <rss>fp-0003.rss.xml</rss>  <addr>fp-0003</addr>  <route>fp-0003.xml</route>   <title>一般函數的設計</title> </frontmatter> <mainmatter><p>
  在一般情況下我們撰寫一個函數習慣將資料擺在最前面，其他參數擺後面。假設今天我們設計一個 Array <code>map</code> 函數：
</p><pre>function map(data, callback){
  let res = [];

  for(const item of data){
      res.push(callback(item))
  }

  return res
}
</pre><p>我們可以利用 <code>map</code> 它再做出新的函數 <code>double</code>：</p><pre>function double(data) {
  return map(data, (num) =&gt; num * 2);
}
</pre><p>但你慢慢就會發現你每利用 <code>map</code> 做一個新的函數出來，你都要重複做一次傳遞 <code>data</code> 的動作。</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>10</crumb></trail> <anchor>422</anchor> <rss>fp-0004.rss.xml</rss>  <addr>fp-0004</addr>  <route>fp-0004.xml</route>   <title>Data last</title> </frontmatter> <mainmatter><p>今天我們轉成 data last 形式來設計 <code>map</code>：</p><pre>function map(callback, data) {
  let res = [];

  for (const item of data) {
    res.push(callback(item));
  }

  return res;
}
</pre><p>我們再嘗試做一個 <code>double</code>：</p><pre>function double(data) {
  return map((num) =&gt; num * 2, data);
}
</pre><p>你會發現你還是要一直傳遞 <code>data</code> ，這到底有什麼差，但我們忘了一件事情是 FP 通常會將函數做<strong>柯里化(curry)</strong>。</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>11</crumb></trail> <anchor>423</anchor> <rss>fp-0005.rss.xml</rss>  <addr>fp-0005</addr>  <route>fp-0005.xml</route>   <title>Data last 搭配柯里化</title> </frontmatter> <mainmatter><p>
我們將 <code>map</code> 函數做柯里化
</p><pre>function map(callback) {
  return function (data) {
    let res = [];

    for (const item of data) {
      res.push(callback(item));
    }

    return res;
  };
}
</pre><p>現在做一個 double 函數只需要傳 callback 即可</p><pre>map((num) =&gt; num * 2);
</pre></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>12</crumb></trail> <anchor>424</anchor> <rss>fp-0006.rss.xml</rss>  <addr>fp-0006</addr>  <route>fp-0006.xml</route>   <title>利於函式組合</title> </frontmatter> <mainmatter><p>一般我們做函式組合通常是 <tex>f</tex> 函數的輸出對應到 <tex>g</tex> 函數的輸入。</p><tex display="block">
  f = a  \to  b, \  g = b  \to  c
</tex><p>
  但現實是並不是每個函數的輸入參數都只有一個，我們必須先給一些參數後才能再跟其他函數接在一起。
  而一般情況下組合會是長這樣：
</p><pre>function fn(data) {
  return map(
    map(data, (num) =&gt; num * 2),
    (num) =&gt; num + 1
  );
}
</pre><p>你每組一個新的函數出來你都得做一次傳遞資料的動作。</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>12</crumb> <crumb>1</crumb></trail> <anchor>425</anchor> <rss>fp-0007.rss.xml</rss>  <addr>fp-0007</addr>  <route>fp-0007.xml</route>   <title>利用 compose</title> </frontmatter> <mainmatter><p>在函數 <strong>data last 搭配柯里化</strong> 的情況下用 <code>compose</code> 來組合函式會乾淨許多。</p><pre>const fn = compose(
  map((num) =&gt; num + 1),
  map((num) =&gt; num * 2)
);
</pre></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>13</crumb></trail> <anchor>426</anchor> <rss>fp-0008.rss.xml</rss>  <addr>fp-0008</addr>  <route>fp-0008.xml</route>   <title>Data first 較優雅的作法</title> </frontmatter> <mainmatter><p>如果不想像一開始那樣一直傳遞 data，但還是想走 data first 形式，有兩種</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>13</crumb> <crumb>1</crumb></trail> <anchor>427</anchor> <rss>fp-0009.rss.xml</rss>  <addr>fp-0009</addr>  <route>fp-0009.xml</route>   <title>Chaining</title> </frontmatter> <mainmatter><p>一種是就是用我們一般 Array methods 的形式串接下去</p><pre>data.map((num) =&gt; num * 2).map((num) =&gt; num + 1);
</pre><p>可以從 <link href="https://lodash.com/docs/#chain" type="external">lodash</link> 找到這種設計方式，但伴隨的缺點是跟其他函式庫沒辦法配合的這麼好。</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>13</crumb> <crumb>2</crumb></trail> <anchor>428</anchor> <rss>fp-000A.rss.xml</rss>  <addr>fp-000A</addr>  <route>fp-000A.xml</route>   <title>略過參數的語法糖</title> </frontmatter> <mainmatter><p>在 Scala 中可以利用 <code>_</code> 來暫時略過參數：</p><pre>List(1, 2, 3, 4).map(_ * 2)
</pre><pre>def multiplier(a: Int, b: Int): Int = a * b

val fourTimes = multiplier(_: Int, 4)

fourTimes(2) // 8
</pre><p>
  我們在 <code>ramda</code> 中會看到一個叫做 <link href="https://ramdajs.com/docs/#__" type="external">placeholder function</link> 來模擬類似 Scala 的效果，它可以保留位置來安插後續進來的參數。

假設我們利用 data first 方式設計 <code>map</code> 並做柯里化，使用 <code>__</code> 函數就會是以下這樣：
</p><pre>const fn = compose(
  map(R.__, (num) =&gt; num + 1),
  map(R.__, (num) =&gt; num * 2)
);
</pre></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>14</crumb></trail> <anchor>429</anchor> <rss>fp-000B.rss.xml</rss>  <addr>fp-000B</addr>  <route>fp-000B.xml</route>   <title>參數的順序會影響結果的函數</title> </frontmatter> <mainmatter><p>有些函數的參數資料格式相同，並且擺放順序不同會影響執行結果。</p><ul><li><code>&lt;</code> lessThan</li>
  <li><code>&lt;=</code> lessThanEqual</li>
  <li><code>&gt;</code> greaterThan</li>
  <li><code>&gt;=</code> greaterThanEqual</li>
  <li><code>concat</code></li></ul><p>
  如果是一般的比大小，我們反轉一下邏輯就可以解決(<code>&lt;</code> 改成 <code>&gt;=</code>)，但 <code>concat</code> 就不行
  假設我們的需求是將主流程的資訊接在 <code>arr</code> 的前面，但一般作法似乎會有錯誤：
</p><pre>flow(
  // ...
  concat(arr) // 前一個的結果會被接在 arr 後面
);
</pre><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>14</crumb> <crumb>1</crumb></trail> <anchor>430</anchor> <rss>fp-000C.rss.xml</rss>  <addr>fp-000C</addr>  <route>fp-000C.xml</route>   <title>重新包裝</title> </frontmatter> <mainmatter><p>一種辦法是我們再包裝一個函數，重新將 data 擺在正確位置</p><pre>flow(
  // ...
  (data) =&gt; concat(data, arr) // 多包一層來擺放正確位置
);
</pre></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>14</crumb> <crumb>2</crumb></trail> <anchor>431</anchor> <rss>fp-000D.rss.xml</rss>  <addr>fp-000D</addr>  <route>fp-000D.xml</route>   <title>Flip</title> </frontmatter> <mainmatter><p>flip 函數可以將你的函數的前兩個參數對調</p><pre>flow(
  // ...
  flip(concat)(arr) // 將參數對調
);
</pre><link href="https://ramdajs.com/docs/#flip" type="external">Ramda <code>flip</code></link></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>14</crumb> <crumb>3</crumb></trail> <anchor>432</anchor> <rss>fp-000E.rss.xml</rss>  <addr>fp-000E</addr>  <route>fp-000E.xml</route>   <title>Placeholder</title> </frontmatter> <mainmatter><p>也可以利用 placeholder function 來消除不必要的包裝跟邏輯反轉。</p><pre>flow(
  // ...
  R.concat(R.__, arr) // 保留第一個位置給後續進來的資料
);
</pre></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>433</anchor> <rss>cat-0005.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0005</addr>  <route>cat-0005.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title><tex>F</tex>-algebra</title> </frontmatter> <mainmatter><p>要理解 <tex>F</tex>-algebra，我們需要一些觀察，第一個是代數可以表示成一組簽名。例如，Monoid 有一組簽名：</p><tex display="block">\begin {cases}
1:1 \to  m  \\ 
 \bullet : m  \times  m  \to  m
 \end {cases}</tex><p>或者你可以將 環（Ring）寫成：</p><tex display="block">\begin {cases}
0: 1  \to  m  \\ 
1:1  \to  m  \\ 
+: m  \times  m  \to  m  \\ 
 \times : m  \times  m  \to  m  \\ 
- : m  \to  m
 \end {cases}</tex><p>我們令 <tex>m</tex> 為範疇 <tex>C</tex> 中的一個 object，要選一個足以表示簽名的範疇，以上面的例子來說需要 <link href="cat-0004.xml" type="local" title="Cartesian closed category">cartesian closed category</link>。</p><ul><li>對 <tex>m</tex> 來說，Monoid 是 <tex>C</tex> 中的一個態射 <tex>1 + m  \times  m  \to  m</tex></li>
<li>對 <tex>m</tex> 來說，環是 <tex>C</tex> 中的一個態射 <tex>1 + 1 + m  \times  m + m  \times  m + m  \to  m</tex></li></ul><p>根據這些，我們把代數的定義推廣為：固定 <tex>F</tex> 函子後，每個 <tex>F(m)  \to  m</tex> 都是一個代數。</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>15</crumb></trail> <anchor>434</anchor> <rss>cat-0006.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0006</addr>  <route>cat-0006.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title><tex>F</tex>-algebra (algebra for an endofunctor)</title> </frontmatter> <mainmatter><p>在一個適當的範疇 <tex>C</tex> 中，我們把簽名改成一個 functor <tex>F</tex>，這個函子投射出的 <tex>F(m)  \to  m</tex> 是 <tex>F</tex>-algebra，記為三元組：</p><tex display="block">(F,x, \alpha )</tex><p>其中 <tex>\alpha  : Fx  \to  x</tex> 是一個 <tex>C</tex> 中的態射。</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>16</crumb></trail> <anchor>435</anchor> <rss>cat-0007.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0007</addr>  <route>cat-0007.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Category of <tex>F</tex>-algebra</title> </frontmatter> <mainmatter><p>functor 與 natural transformation 構成 functor category</p><p>對於在一個適當的範疇 <tex>C</tex> 中固定的自函子 <tex>F</tex> (以下省略 <tex>F</tex> 符號)</p><ol><li>object 是全部的 <tex>F</tex>-algebra。</li>
    <li>態射皆為 <tex>(x, \alpha ) \xrightarrow {Fm} (y, \beta )</tex> 對象的同態，組合由函子定律給出。</li></ol><p>同態是令下圖交換的態射 <tex>m</tex></p><img src="resources/d03b1d03463b38b59f031dfd8db6243a-web.svg"/><p>額外檢查我們可以發現 identity 也如預期運作</p><img src="resources/1cd56e6d25fa67f9f68ba8f65416e8fe-web.svg"/></mainmatter> </tree><p>這些是跟範疇中初始對象 (initial object) 有關的一個定理</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>17</crumb></trail> <anchor>436</anchor> <rss>cat-0008.rss.xml</rss> <taxon>Theorem</taxon> <addr>cat-0008</addr>  <route>cat-0008.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Lambek's</title> </frontmatter> <mainmatter><p>初始代數是同構態射</p><block open="open"><headline><strong>證明</strong></headline> 
讓 <tex>Fi</tex> 成為 <tex>F</tex>-algebra 範疇中的初始對象，對於 <tex>C</tex> 中所有對象 <tex>a</tex> 產生以下交換圖
</block><img src="resources/e4cb34d49f4c3269b36a2ad932d2a830-web.svg"/><p>現在我們將 <tex>a</tex> 替換成 <tex>Fi</tex></p><img src="resources/654e7ee73514b1908ce0609018ec28b2-web.svg"/><p>再來透過複製路徑 <tex>Fi  \to  i</tex> 得出以下交換圖</p><img src="resources/a4215cc67d90b26f2eefca8d2b2e9342-web.svg"/><p>將兩張交換圖合併</p><img src="resources/de1f16cbe506cbfdd91d68ae1ed8d213-web.svg"/><p>透過定義，我們現在知道 <tex>j  \circ  m</tex> 是同態(homomorphism)，並且因為 <tex>Fi</tex> 為初始對象我們得到</p><tex display="block">Fj  \circ  Fm = 1_{Fi}</tex><p>所以，我們也得出</p><tex display="block">j  \circ  m = 1_{i}</tex><p>因此 <tex>m</tex> 是 <tex>j</tex> 的 inverse，證明 <tex>j</tex> 是同構。</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>18</crumb></trail> <anchor>437</anchor> <rss>cat-0009.rss.xml</rss>  <addr>cat-0009</addr>  <route>cat-0009.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Catamorphism</title> </frontmatter> <mainmatter><p>根據 Lambek's 理論可以畫出交換圖</p><img src="resources/a335c1e139435a417620af4f5ed1899d-web.svg"/><p>在 Haskell 中，我們可以這樣定義初始代數</p><block open="open"><headline><strong>Haskell</strong></headline> <pre>newtype Fix f = Fix (f (Fix f))

unFix :: Fix f -&gt; f (Fix f)
unFix (Fix x) = x
</pre></block><p>將 <tex>j</tex> 視為 <code>Fix</code> 建構子，<tex>j^{-1}</tex> 為 <code>unFix</code>，再來我們可以定義 <code>m = alg . fmap m . unFix</code>。因為 <code>m :: Fix f -&gt; a</code>，我們有了 Catamorphism 的程式定義</p><block open="open"><headline><strong>Haskell</strong></headline> <pre>cata :: Functor f =&gt; (f a -&gt; a) -&gt; Fix f -&gt; a
cata alg = alg . fmap (cata alg) . unFix
</pre></block><p><code>foldr</code> 是一個常見的例子，它是 Catamorphism 的一種便利版本。</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>19</crumb></trail> <anchor>438</anchor> <rss>cat-000A.rss.xml</rss>  <addr>cat-000A</addr>  <route>cat-000A.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Anamorphism</title> </frontmatter> <mainmatter><p>作為一個對偶概念，可以畫出一個 coalgebra 的圖，我們稱這種關係為 anamorphism。</p><img src="resources/1d52730693bfbe9b6480854492250569-web.svg"/></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>439</anchor> <rss>cat-0006.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0006</addr>  <route>cat-0006.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title><tex>F</tex>-algebra (algebra for an endofunctor)</title> </frontmatter> <mainmatter><p>在一個適當的範疇 <tex>C</tex> 中，我們把簽名改成一個 functor <tex>F</tex>，這個函子投射出的 <tex>F(m)  \to  m</tex> 是 <tex>F</tex>-algebra，記為三元組：</p><tex display="block">(F,x, \alpha )</tex><p>其中 <tex>\alpha  : Fx  \to  x</tex> 是一個 <tex>C</tex> 中的態射。</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>440</anchor> <rss>cat-000A.rss.xml</rss>  <addr>cat-000A</addr>  <route>cat-000A.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Anamorphism</title> </frontmatter> <mainmatter><p>作為一個對偶概念，可以畫出一個 coalgebra 的圖，我們稱這種關係為 anamorphism。</p><img src="resources/1d52730693bfbe9b6480854492250569-web.svg"/></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>441</anchor> <rss>cat-0009.rss.xml</rss>  <addr>cat-0009</addr>  <route>cat-0009.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Catamorphism</title> </frontmatter> <mainmatter><p>根據 Lambek's 理論可以畫出交換圖</p><img src="resources/a335c1e139435a417620af4f5ed1899d-web.svg"/><p>在 Haskell 中，我們可以這樣定義初始代數</p><block open="open"><headline><strong>Haskell</strong></headline> <pre>newtype Fix f = Fix (f (Fix f))

unFix :: Fix f -&gt; f (Fix f)
unFix (Fix x) = x
</pre></block><p>將 <tex>j</tex> 視為 <code>Fix</code> 建構子，<tex>j^{-1}</tex> 為 <code>unFix</code>，再來我們可以定義 <code>m = alg . fmap m . unFix</code>。因為 <code>m :: Fix f -&gt; a</code>，我們有了 Catamorphism 的程式定義</p><block open="open"><headline><strong>Haskell</strong></headline> <pre>cata :: Functor f =&gt; (f a -&gt; a) -&gt; Fix f -&gt; a
cata alg = alg . fmap (cata alg) . unFix
</pre></block><p><code>foldr</code> 是一個常見的例子，它是 Catamorphism 的一種便利版本。</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>442</anchor> <rss>cat-0007.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0007</addr>  <route>cat-0007.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Category of <tex>F</tex>-algebra</title> </frontmatter> <mainmatter><p>functor 與 natural transformation 構成 functor category</p><p>對於在一個適當的範疇 <tex>C</tex> 中固定的自函子 <tex>F</tex> (以下省略 <tex>F</tex> 符號)</p><ol><li>object 是全部的 <tex>F</tex>-algebra。</li>
    <li>態射皆為 <tex>(x, \alpha ) \xrightarrow {Fm} (y, \beta )</tex> 對象的同態，組合由函子定律給出。</li></ol><p>同態是令下圖交換的態射 <tex>m</tex></p><img src="resources/d03b1d03463b38b59f031dfd8db6243a-web.svg"/><p>額外檢查我們可以發現 identity 也如預期運作</p><img src="resources/1cd56e6d25fa67f9f68ba8f65416e8fe-web.svg"/></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>443</anchor> <rss>fp-000H.rss.xml</rss>  <addr>fp-000H</addr>  <route>fp-000H.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>FP 的 Functor 與範疇論的 Functor 之間的關聯</title> </frontmatter> <mainmatter><p>
  即便我們看了<link href="cat-0002.xml" type="local" title="Functor">範疇論</link>跟 FP 語言中的 Functor 定義，但在概念的銜接上仍然有困難，如果你看了 <link href="https://en.wikipedia.org/wiki/Functor_(functional_programming)" type="external">Functor(functional programming) wiki</link> 會發現他是受範疇論啟發的 design pattern。而到底引用了哪些概念，以及與語言能做到什麼程度，並沒有很好的說明。
</p><p>
  如果以「Functor 是兩個範疇之間的映射」這個觀點來看程式中的 Functor 似乎有些奇怪，通常我們看到的範例都是舉兩個不同範疇 <tex>C,D</tex>，如果某一程式語言是一個範疇 <tex>C</tex> 的話，那範疇 <tex>D</tex> 就會是另一個語言，雖然我們常常這樣思考，但是我們定義程式裡面的 Functor 時不想弄得太複雜。所以這裡指的都是「 <tex>C</tex> 與 <tex>C</tex> 之間的映射」，也就是 <strong>Endofunctor</strong> 。你可以在 <link href="https://wiki.haskell.org/Typeclassopedia" type="external">Haskell wiki</link> 以及 fp-ts 作者所寫的 <link href="https://github.com/enricopolanski/functional-programming#a-boundary-that-leads-to-functors" type="external">Introduction to Functional Programming</link> 中找到相關說明。
</p><blockquote><p>Technically, these laws make f and fmap together an endofunctor on Hask, the category of Haskell types (ignoring <link href="https://wiki.haskell.org/Bottom" type="external">⊥</link>, which is a party pooper). See <link href="https://en.wikibooks.org/wiki/Haskell/Category_theory" type="external">Wikibook: Category theory</link>.</p></blockquote><blockquote><p>
    Even though a map between two different programming languages is a fascinating idea, we're more interested in a map where C and D are the same (the TS category). In that case we're talking about <strong>endofunctors</strong> (from the greek &quot;endo&quot; meaning &quot;inside&quot;, &quot;internal&quot;).
  </p></blockquote><p>
  範疇論跟程式語言定義的 Functor 不是完全一樣的概念，因為大部分的語言並不可能寫出<link href="https://ncatlab.org/nlab/show/type+of+propositions" type="external">命題</link>，所以範疇論的限制語言裡不一定有加上，這之間的一些漏洞就會產生對使用者來說可能很奇怪的結果，我們能做的就是將兩者之間重疊的部份做連結。而 Haskell 是透過 <link href="https://wiki.haskell.org/Typeclassopedia" type="external">Typeclass</link> 來做約束，所以在程式語言的語境下所說的 Functor 是指 type class 的定義。另外，我們常說「Maybe 是一個 Functor」 指的是 Maybe 是 Functor class 的一個實例 (Maybe 可替換任何其他 Functor class 實例)。
</p><p>
  其他 FP 語言雖然不一定都使用 Typeclass 這個詞，但大多 Functor 的定義都差不多。
</p><block open="open"><headline><strong>Haskell</strong></headline> 
<pre>class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</pre>
</block><block open="open"><headline><strong>Scala</strong></headline> 
<pre>trait Functor[F[_]] {
  def map[A,B](a: F[A])(f: A =&gt; B): F[B]
}
</pre>
</block><block open="open"><headline><strong>Lean</strong></headline> 
<pre>class Functor (f : Type u → Type v) : Type (max (u+1) v) where
  map : {α β : Type u} → (α → β) → f α → f β
</pre>
</block><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>20</crumb></trail> <anchor>444</anchor> <rss>fp-000P.rss.xml</rss>  <addr>fp-000P</addr>  <route>fp-000P.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Functor Laws</title> </frontmatter> <mainmatter><p>
    Functor class 的實例不能視為範疇論中的 Functor，必須檢查 Functor 的約束才會是真正的 Functor。
</p><tex display="block">
fmap \  id = id
 \\ 
fmap \  (g \circ  f) = fmap \  g  \circ  fmap \  f
</tex></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>445</anchor> <rss>fp-000P.rss.xml</rss>  <addr>fp-000P</addr>  <route>fp-000P.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Functor Laws</title> </frontmatter> <mainmatter><p>
    Functor class 的實例不能視為範疇論中的 Functor，必須檢查 Functor 的約束才會是真正的 Functor。
</p><tex display="block">
fmap \  id = id
 \\ 
fmap \  (g \circ  f) = fmap \  g  \circ  fmap \  f
</tex></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>446</anchor> <rss>cat-0008.rss.xml</rss> <taxon>Theorem</taxon> <addr>cat-0008</addr>  <route>cat-0008.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Lambek's</title> </frontmatter> <mainmatter><p>初始代數是同構態射</p><block open="open"><headline><strong>證明</strong></headline> 
讓 <tex>Fi</tex> 成為 <tex>F</tex>-algebra 範疇中的初始對象，對於 <tex>C</tex> 中所有對象 <tex>a</tex> 產生以下交換圖
</block><img src="resources/e4cb34d49f4c3269b36a2ad932d2a830-web.svg"/><p>現在我們將 <tex>a</tex> 替換成 <tex>Fi</tex></p><img src="resources/654e7ee73514b1908ce0609018ec28b2-web.svg"/><p>再來透過複製路徑 <tex>Fi  \to  i</tex> 得出以下交換圖</p><img src="resources/a4215cc67d90b26f2eefca8d2b2e9342-web.svg"/><p>將兩張交換圖合併</p><img src="resources/de1f16cbe506cbfdd91d68ae1ed8d213-web.svg"/><p>透過定義，我們現在知道 <tex>j  \circ  m</tex> 是同態(homomorphism)，並且因為 <tex>Fi</tex> 為初始對象我們得到</p><tex display="block">Fj  \circ  Fm = 1_{Fi}</tex><p>所以，我們也得出</p><tex display="block">j  \circ  m = 1_{i}</tex><p>因此 <tex>m</tex> 是 <tex>j</tex> 的 inverse，證明 <tex>j</tex> 是同構。</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>447</anchor> <rss>fp-000K.rss.xml</rss> <taxon>Definition</taxon> <addr>fp-000K</addr>  <route>fp-000K.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>函數</title> </frontmatter> <mainmatter><p>在數學中，函數是一個集合 (稱為<strong>定義域 domain</strong>) 到另一個集合 (稱為<strong>值域 codomain</strong>) 的映射，假設我們有個函數 <tex>f:A  \to  B</tex>，則 <tex>A</tex> (domain) 中每個元素都必須對應到 <tex>B</tex>(codomain) 中的一個元素，能達成 <tex>A  \to  B</tex> 條件的函數總共有 <tex>|B|^{|A|}</tex> 種，我們能實現的是有限的語法能實現的一小部分，而不是所有都實現。</p><p>Typescript</p><pre>
// isEven : number -&gt; boolean
function isEven(num: number): boolean {
    return num % 2 === 0
}
</pre><p>Haskell</p><pre>is_even :: Int -&gt; Bool
is_even n = n `mod` 2 == 0
</pre><p>函數分三種類型，包含 <strong>單射 (injection)</strong>、<strong>滿射 (surjection)</strong>、<strong>對射 (bijection)</strong>。</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>21</crumb></trail> <anchor>448</anchor> <rss>fp-000L.rss.xml</rss>  <addr>fp-000L</addr>  <route>fp-000L.xml</route>   <title>單射 (injection)</title> </frontmatter> <mainmatter><p>假設我們稱一個函數 <tex>f:A  \to  B</tex> 是單射，則 <tex>A</tex> 與 <tex>B</tex> 的元素關係都是一對一的，即</p><tex display="block">\forall  a,b \in  A, \  a \neq  b  \Longrightarrow  f(a) \neq  f(b)</tex><figure>
  <img src="images/fp-000L/injection.png"/>
  <figcaption>injection</figcaption>
</figure><p>我們可以從中得知另一個訊息是 <tex>A</tex> 中的元素數量會小於等於 <tex>B</tex> 元素數量，即 <tex>|A| \le  |B|</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>22</crumb></trail> <anchor>449</anchor> <rss>fp-000M.rss.xml</rss>  <addr>fp-000M</addr>  <route>fp-000M.xml</route>   <title>滿射 (surjection)</title> </frontmatter> <mainmatter><p>我們稱一個函數 <tex>f : A  \to  B</tex> 是滿射，則對於 <tex>B</tex> 中所有的元素，都存在至少一個 <tex>A</tex> 元素與其對應，即</p><tex display="block">\forall  b  \in  B, \  \exist  a  \in  A, \  f(a) = b</tex><figure>
  <img src="images/fp-000M/surjection.png"/>
  <figcaption>surjection</figcaption>
</figure><p>我們可以從中得知另一個訊息是 <tex>A</tex> 中的元素數量會大於等於 <tex>B</tex> 元素數量，即 <tex>|A|  \ge  |B|</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>23</crumb></trail> <anchor>450</anchor> <rss>fp-000N.rss.xml</rss>  <addr>fp-000N</addr>  <route>fp-000N.xml</route>   <title>對射 (bijection)</title> </frontmatter> <mainmatter><p>我們稱一個函數 <tex>f : A  \to  B</tex> 是對射，則該函數同時達成單射與滿射條件，因為同時滿足 <tex>|A| \le  |B|</tex> 跟 <tex>|A| \ge  |B|</tex> 則 <tex>|A| = |B|</tex></p><figure>
  <img src="images/fp-000N/bijection.png"/>
  <figcaption>bijection</figcaption>
</figure></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>451</anchor> <rss>fp-000G.rss.xml</rss>  <addr>fp-000G</addr>  <route>fp-000G.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>實際上的用途</title> </frontmatter> <mainmatter><p>
	可以將一個 pure function 應用到容器型別之中。
	單純從容器的角度來看，就像是隱藏了「取出 → 運算 → 放回去」的過程，而根據每個容器用途不同在過程中執行不同操作及判斷。
</p><img src="resources/c153deb1fe8bd64db16ba299c55cf845-web.svg"/><p>
	雖然 polymorphism 的容器解釋非常方便，卻是眾多誤解的根源之一。實際上不能做這麼簡單的解釋，舉例來說我可以定義 <tex>F(-) = (c  \to  -)</tex>，於是 <tex>F(a)  \to  F(b)</tex> 視同 <tex>(c  \to  a)  \to  (c  \to  b)</tex>，令 <tex>g : c  \to  a, f : a  \to  b</tex>，<tex>\lambda  c.  \lambda  g. f(g(c))</tex> 正是一個 functor。
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>452</anchor> <rss>fp-000I.rss.xml</rss>  <addr>fp-000I</addr>  <route>fp-000I.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>常見的 Functor Type</title> </frontmatter> <mainmatter><ul><li>
    Maybe / Option
    <ul><li>Haskell (Maybe)</li>
      <li>Lean (Option)</li>
      <li>Rust (Option)</li></ul></li>
  <li>
    Either / Result / Except
    <ul><li>Haskell (Either)</li>
      <li>Result (Rust)</li>
      <li>Lean (Except)</li></ul></li>
  <li>
    IO
    <ul><li>Haskell (IO)</li>
      <li>Lean (IO)</li></ul></li>

  <li>
    Reader
    待補
  </li>
  <li>
    Writer
    待補
  </li>
  <li>
    State
    待補
  </li></ul></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>453</anchor> <rss>fp-000J.rss.xml</rss> <taxon>Definition</taxon> <addr>fp-000J</addr>  <route>fp-000J.xml</route>  <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author> </authors> <title>純函數 (Pure function)</title> </frontmatter> <mainmatter><p>純函數的意義是我們想讓編譯器可以做公共子常式提取跟幾種循環等最佳化而試圖去探尋的某一類函數，進而是一種有效減輕開發上的心智負擔，是能夠被靈活組合的一類函數。在程式中你可以利用函數做許多事情，不只是單純的運算，還包含了各種值的修改及各種非同步操作，雖然方便但也造成了閱讀及維護上的困難。</p><p>由於上述的最佳化都涉及到複製或是共用函數呼叫，因此可以導出這些函數在系統下的任何情形中對相同輸入都能給出相同的輸出。這個部分讓我們推導出一些性質，比如這類函數絕對不跟其他函數共用任何儲存機制，而是只用參數跟回傳處理讀寫的概念。再來函數不應該有副作用，否則增加或是減少函數呼叫都會導致不同的副作用結果。</p><p>因為程式語言裡面必須面對無法判定任意計算是否停機的關係，所以建模型的時候都會留下一個對應到 <strong>undefined</strong> (<tex>\bot</tex>) 的位置，這樣的概念叫做 partial function，跟數學上的<link href="fp-000K.xml" type="local" title="函數">全函數</link>有所差異。</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>24</crumb></trail> <anchor>454</anchor> <rss>fp-000F.rss.xml</rss>  <addr>fp-000F</addr>  <route>fp-000F.xml</route> <date><year>2023</year> <month>10</month> <day>15</day></date> <authors><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>透過單元測試難易度辨別函式純度</title> </frontmatter> <mainmatter><p>身為一個初學者該如何知道自己的函數有多純？其實在進行單元測試時可以很容易觀察到，以下會有兩點可以注意：</p><ul><li>是否依賴外部資源及變數導致你需要使用 mock data？
    <br/>你必須創造一些虛假的上下文才能使你的函數正常運作，代表這函數過度依賴環境，在遷移上相對困難許多。</li>

    <li>你的函數執行完是否會導致外部變數被修改？
    <br/>函數應該盡可能減少對外部影響，否則在追蹤錯誤時會變得越來越困難。</li></ul><p>除了函數本身的行為必須正確之外，一個函數無論遷移到何種新環境時都不會改變其行為，也不會對該環境產生任何影響，這個函數才稱得上足夠純。然而，在現實程式中，很難實現所有函數都是純函數的理想情況。我們能做的是盡量減少非純函數，以降低維護成本。</p><p>透過單元測試，不僅可以檢驗你的函數是否如預期執行，還可以讓你重新審視該函數的定位，並且培養撰寫純函數的直覺。</p></mainmatter> </tree></mainmatter> </tree></contributions> <context/> <related/> <backlinks/> <references/></backmatter></tree>