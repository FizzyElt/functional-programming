<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>337</anchor> <rss>cat-0006.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0006</addr>  <route>cat-0006.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title><tex>F</tex>-algebra (algebra for an endofunctor)</title> </frontmatter> <mainmatter><p>在一個適當的範疇 <tex>C</tex> 中，我們把簽名改成一個 functor <tex>F</tex>，這個函子投射出的 <tex>F(m)  \to  m</tex> 是 <tex>F</tex>-algebra，記為三元組：</p><tex display="block">(F,x, \alpha )</tex><p>其中 <tex>\alpha  : Fx  \to  x</tex> 是一個 <tex>C</tex> 中的態射。</p></mainmatter> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>338</anchor> <rss>cat-0005.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0005</addr>  <route>cat-0005.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title><tex>F</tex>-algebra</title> </frontmatter> <mainmatter><p>要理解 <tex>F</tex>-algebra，我們需要一些觀察，第一個是代數可以表示成一組簽名。例如，Monoid 有一組簽名：</p><tex display="block">\begin {cases}
1:1 \to  m  \\ 
 \bullet : m  \times  m  \to  m
 \end {cases}</tex><p>或者你可以將 環（Ring）寫成：</p><tex display="block">\begin {cases}
0: 1  \to  m  \\ 
1:1  \to  m  \\ 
+: m  \times  m  \to  m  \\ 
 \times : m  \times  m  \to  m  \\ 
- : m  \to  m
 \end {cases}</tex><p>我們令 <tex>m</tex> 為範疇 <tex>C</tex> 中的一個 object，要選一個足以表示簽名的範疇，以上面的例子來說需要 <link href="cat-0004.xml" type="local" title="Cartesian closed category">cartesian closed category</link>。</p><ul><li>對 <tex>m</tex> 來說，Monoid 是 <tex>C</tex> 中的一個態射 <tex>1 + m  \times  m  \to  m</tex></li>
<li>對 <tex>m</tex> 來說，環是 <tex>C</tex> 中的一個態射 <tex>1 + 1 + m  \times  m + m  \times  m + m  \to  m</tex></li></ul><p>根據這些，我們把代數的定義推廣為：固定 <tex>F</tex> 函子後，每個 <tex>F(m)  \to  m</tex> 都是一個代數。</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb></trail> <anchor>339</anchor> <rss>cat-0007.rss.xml</rss> <taxon>Definition</taxon> <addr>cat-0007</addr>  <route>cat-0007.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Category of <tex>F</tex>-algebra</title> </frontmatter> <mainmatter><p>functor 與 natural transformation 構成 functor category</p><p>對於在一個適當的範疇 <tex>C</tex> 中固定的自函子 <tex>F</tex> (以下省略 <tex>F</tex> 符號)</p><ol><li>object 是全部的 <tex>F</tex>-algebra。</li>
    <li>態射皆為 <tex>(x, \alpha ) \xrightarrow {Fm} (y, \beta )</tex> 對象的同態，組合由函子定律給出。</li></ol><p>同態是令下圖交換的態射 <tex>m</tex></p><img src="resources/d03b1d03463b38b59f031dfd8db6243a-web.svg"/><p>額外檢查我們可以發現 identity 也如預期運作</p><img src="resources/1cd56e6d25fa67f9f68ba8f65416e8fe-web.svg"/></mainmatter> </tree><p>這些是跟範疇中初始對象 (initial object) 有關的一個定理</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb></trail> <anchor>340</anchor> <rss>cat-0008.rss.xml</rss> <taxon>Theorem</taxon> <addr>cat-0008</addr>  <route>cat-0008.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Lambek's</title> </frontmatter> <mainmatter><p>初始代數是同構態射</p><block open="open"><headline><strong>證明</strong></headline> 
讓 <tex>Fi</tex> 成為 <tex>F</tex>-algebra 範疇中的初始對象，對於 <tex>C</tex> 中所有對象 <tex>a</tex> 產生以下交換圖
</block><img src="resources/e4cb34d49f4c3269b36a2ad932d2a830-web.svg"/><p>現在我們將 <tex>a</tex> 替換成 <tex>Fi</tex></p><img src="resources/654e7ee73514b1908ce0609018ec28b2-web.svg"/><p>再來透過複製路徑 <tex>Fi  \to  i</tex> 得出以下交換圖</p><img src="resources/a4215cc67d90b26f2eefca8d2b2e9342-web.svg"/><p>將兩張交換圖合併</p><img src="resources/de1f16cbe506cbfdd91d68ae1ed8d213-web.svg"/><p>透過定義，我們現在知道 <tex>j  \circ  m</tex> 是同態(homomorphism)，並且因為 <tex>Fi</tex> 為初始對象我們得到</p><tex display="block">Fj  \circ  Fm = 1_{Fi}</tex><p>所以，我們也得出</p><tex display="block">j  \circ  m = 1_{i}</tex><p>因此 <tex>m</tex> 是 <tex>j</tex> 的 inverse，證明 <tex>j</tex> 是同構。</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb></trail> <anchor>341</anchor> <rss>cat-0009.rss.xml</rss>  <addr>cat-0009</addr>  <route>cat-0009.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Catamorphism</title> </frontmatter> <mainmatter><p>根據 Lambek's 理論可以畫出交換圖</p><img src="resources/a335c1e139435a417620af4f5ed1899d-web.svg"/><p>在 Haskell 中，我們可以這樣定義初始代數</p><block open="open"><headline><strong>Haskell</strong></headline> <pre>newtype Fix f = Fix (f (Fix f))

unFix :: Fix f -&gt; f (Fix f)
unFix (Fix x) = x
</pre></block><p>將 <tex>j</tex> 視為 <code>Fix</code> 建構子，<tex>j^{-1}</tex> 為 <code>unFix</code>，再來我們可以定義 <code>m = alg . fmap m . unFix</code>。因為 <code>m :: Fix f -&gt; a</code>，我們有了 Catamorphism 的程式定義</p><block open="open"><headline><strong>Haskell</strong></headline> <pre>cata :: Functor f =&gt; (f a -&gt; a) -&gt; Fix f -&gt; a
cata alg = alg . fmap (cata alg) . unFix
</pre></block><p><code>foldr</code> 是一個常見的例子，它是 Catamorphism 的一種便利版本。</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb></trail> <anchor>342</anchor> <rss>cat-000A.rss.xml</rss>  <addr>cat-000A</addr>  <route>cat-000A.xml</route>  <authors><author><link href="dannypsnl.xml" type="local">Lîm Tsú-thuàn</link></author><author><link href="fizzyelt.xml" type="local">FizzyElt</link></author> </authors> <title>Anamorphism</title> </frontmatter> <mainmatter><p>作為一個對偶概念，可以畫出一個 coalgebra 的圖，我們稱這種關係為 anamorphism。</p><img src="resources/1d52730693bfbe9b6480854492250569-web.svg"/></mainmatter> </tree></mainmatter> </tree></context> <related/> <backlinks/> <references/></backmatter></tree>